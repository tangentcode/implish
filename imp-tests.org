#+title: implish tests
#+server: https://tangentcode.com/
#+name: implish

* DONE repl behavior: print everything but nil
#+name: nil
#+begin_src
> [nil]
[nil]
> nil
> 1 `x
`x
#+end_src

* DONE echo "hello"
#+name: hello.applicative
#+begin_src
> echo "hello"
hello
#+end_src
* DONE echo 2 + 2
#+name: add
#+begin_src
> echo 2 + 2
4
#+end_src

outputing "2 2" would be reasonable here if you don't look ahead for operators. So this test forces you to define operators, and look ahead multiple tokens.

- next -> echo (verb)
- have verb, so look ahead for adverb/conjunction/
- peek -> 2 (noun)
- okay. we will apply verb to noun
- fetch full noun phrase, by calling "next"
- next -> 2 (noun)
- have noun, so look ahead for .method or infix op


* DONE arithmetic (left to right eval)
#+name: arithmetic
#+begin_src
> echo 1 + 2 * 3 + 5
14
#+end_src

* DONE ignore comments
#+name: echo-comment
#+begin_src
> echo .: this is a comment :. "hi"
hi
#+end_src

* DONE echo show "quoted"
#+name: echo-show
#+begin_src
> echo show "quoted"
"quoted"
#+end_src


* DONE echo["hello"]
#+name: hello.projection
#+begin_src
> echo["hello"]
hello
#+end_src

* DONE echo[2 + 2]
#+name: projection.with-op
#+begin_src
> echo[2 + 2]
4
#+end_src

* DONE +[2;3]
#+name: projection.op
#+begin_src
> +[2;3]
5
#+end_src

* DONE echo[+[2;3]]
#+name: projection.nested
#+begin_src
> echo[+[2;3]]
5
#+end_src



* DONE echo xmls '[1 2; "three"; four]
#+name: xmls
#+begin_src imp
> echo xmls [1 2; "three"; 'four]
<imp:lst open="[" close="]">
  <imp:ints v="1 2"/>
  <imp:str v="three"/>
  <imp:sym k="lit" v="four"/>
</imp:lst>
#+end_src

* DONE word type round-tripping: basic types
#+name: word-types-basic
#+begin_src imp
> echo xmls '['foo :bar baz:]
<imp:lst open="[" close="]">
  <imp:sym k="lit" v="foo"/>
  <imp:sym k="get" v="bar"/>
  <imp:sym k="set" v="baz"/>
</imp:lst>
#+end_src

* DONE word type round-tripping: refinement, path, and file
#+name: word-types-refn-path-file
#+begin_src imp
> echo xmls [/refn foo/bar %file/path]
<imp:lst open="[" close="]">
  <imp:sym k="refn" v="refn"/>
  <imp:sym k="path" v="foo/bar"/>
  <imp:sym k="file" v="file/path"/>
</imp:lst>
#+end_src

* TODO word type round-tripping: issue
NOTE: Can't test #abc in tanco because # starts a comment
#+name: word-types-ish
#+begin_src imp
# > xmls [#abc]
# [#abc]
#+end_src

* DONE word type round-tripping: URL
#+name: word-types-url
#+begin_src imp
> echo xmls [http://example.com]
<imp:lst open="[" close="]">
  <imp:sym k="url" v="http://example.com"/>
</imp:lst>
#+end_src

* DONE new symbol types: backtick and type
#+name: word-types-new1
#+begin_src imp
> echo xmls [`foo bar!]
<imp:lst open="[" close="]">
  <imp:sym k="bqt" v="foo"/>
  <imp:sym k="typ" v="bar"/>
</imp:lst>
#+end_src

* DONE new symbol types: annotation and messages
#+name: word-types-new2
#+begin_src imp
> echo xmls '[@note .msg .kw:]
<imp:lst open="[" close="]">
  <imp:sym k="ann" v="note"/>
  <imp:sym k="msg" v="msg"/>
  <imp:sym k="kw" v="kw"/>
</imp:lst>
#+end_src

* DONE new symbol types: message2 and keyword2
#+name: word-types-new3
#+begin_src imp
> echo xmls '[!msg2 !kw2:]
<imp:lst open="[" close="]">
  <imp:sym k="msg2" v="msg2"/>
  <imp:sym k="kw2" v="kw2"/>
</imp:lst>
#+end_src

* DONE new symbol type: error
#+name: word-types-err
#+begin_src imp
> echo xmls [?error]
<imp:lst open="[" close="]">
  <imp:sym k="err" v="error"/>
</imp:lst>
#+end_src

* DONE backtick tokenization: no spaces needed
#+name: backtick-tokenization
#+begin_src imp
> echo xmls '[`foo`bar`baz]
<imp:lst open="[" close="]">
  <imp:sym k="bqt" v="foo"/>
  <imp:sym k="bqt" v="bar"/>
  <imp:sym k="bqt" v="baz"/>
</imp:lst>
#+end_src

* DONE quoted list with backtick (quasiquote)
#+name: quoted-list-backtick
#+begin_src imp
> `[1 2 3]
[1 2 3]
#+end_src

* DONE quoted list with quote (strips one layer)
#+name: quoted-list-quote
#+begin_src imp
> '[a b c]
[a b c]
#+end_src

* DONE quoted list with nested quotes
#+name: quoted-list-nested
#+begin_src imp
> '[a 'b '[c]]
[a 'b '[c]]
#+end_src

* DONE assignment: basic
#+name: assignment-basic
#+begin_src imp
> x: 42
42
> x
42
#+end_src

* DONE assignment: with expression
#+name: assignment-expr
#+begin_src imp
> y: 2 + 3
5
> y
5
#+end_src

* DONE assignment: use assigned value
#+name: assignment-use
#+begin_src imp
> a: 10
10
> b: a + 5
15
> b
15
#+end_src

* DONE assignment: chained
#+name: assignment-chained
#+begin_src imp
> x: y: 42
42
> x
42
> y
42
#+end_src

* DONE assignment: in operator context
#+name: assignment-in-operator
#+begin_src imp
> 1 + a: 2 3 4
3 4 5
> a
2 3 4
> 5 * b: 3
15
> b
3
#+end_src

* DONE load: parse string
#+name: load-string
#+begin_src imp
> load "2 + 3"
2 + 3
#+end_src

* DONE file operations: e?, wr, rd, rm
#+name: file-ops
#+begin_src imp
> f: %hello.txt
%hello.txt
> e? f
0
> wr f "test content"
> e? f
1
> rd f
"test content"
> rm f
#+end_src

* DONE quasiquotation: basic unquote
#+name: quasiquote-basic
#+begin_src imp
> x: 42
42
> `[1 2 ,x]
[1 2 42]
#+end_src

* DONE quasiquotation: unquote with expression
#+name: quasiquote-expr
#+begin_src imp
> a: 10
10
> b: 20
20
> `[sum is ,a plus ,b]
[sum is 10 plus 20]
#+end_src

* DONE quasiquotation: nested lists
#+name: quasiquote-nested
#+begin_src imp
> y: 99
99
> `[outer [inner ,y]]
[outer [inner 99]]
#+end_src

* DONE quasiquotation: unquote quoted symbol
#+name: quasiquote-unquote-lit
#+begin_src imp
> x: 'two
'two
> `[one ,x three]
[one two three]
#+end_src

* DONE strands: integer vector
#+name: strand-ints
#+begin_src imp
> 1 2 3
1 2 3
> echo 1 2 3 4 5
1 2 3 4 5
#+end_src

* DONE strands: single integer is not a strand
#+name: strand-single
#+begin_src imp
> 42
42
#+end_src

* DONE strands: backtick symbol vector
#+name: strand-syms
#+begin_src imp
> `a `b `c
`a `b `c
> echo `foo `bar `baz
`foo `bar `baz
#+end_src

* DONE strands: scalar plus vector
#+name: strand-scalar-vector
#+begin_src imp
> 1 + 0 1 2
1 2 3
#+end_src

* DONE strands: separated by operators
#+name: strand-ops
#+begin_src imp
> 1 2 + 3 4
4 6
#+end_src

* DONE strands: in projection
#+name: strand-projection
#+begin_src imp
> echo[1 2 3]
1 2 3
#+end_src

* DONE type? introspection
#+name: type-int
#+begin_src imp
> echo show type? 3
int!
#+end_src

#+name: type-str
#+begin_src imp
> echo show type? "hello"
str!
#+end_src

#+name: type-sym
#+begin_src imp
> echo show type? `foo
sym!
#+end_src

#+name: type-list
#+begin_src imp
> echo show type? [1 2 3]
lst!
#+end_src

#+name: type-vector-ints
#+begin_src imp
> echo show type? 1 2 3
ints!
#+end_src

#+name: type-nil
#+begin_src imp
> echo show type? nil
nil!
#+end_src

* DONE arithmetic operators
#+name: arithmetic-ops
#+begin_src imp
> 10 + 5
15
> 10 - 5
5
> 10 * 5
50
> 10 % 3
3
> 2 ^ 8
256
#+end_src

* DONE min and max operators
#+name: min-max
#+begin_src imp
> min[3; 7]
3
> max[3; 7]
7
> 1 2 3 min 2 4 1
1 2 1
#+end_src

* DONE tk (take) operator: scalars and vectors
#+name: take-nums
#+begin_src imp
> 5 tk 10
10 10 10 10 10
> 3 tk 1 2
1 2 1
> 4 tk 7 8 9
7 8 9 7
#+end_src

* DONE tk (take) operator: strings and lists
#+name: take-str-lst
#+begin_src imp
> 7 tk "abc"
"abcabca"
> 5 tk '[x y]
[x y x y x]
#+end_src

* DONE rev (reverse)
#+name: rev
#+begin_src imp
> rev 1 2 3 4
4 3 2 1
> rev '[a b c]
[c b a]
> rev `x `y `z
`z `y `x
#+end_src

* DONE len (length)
#+name: len
#+begin_src imp
> len 1 2 3
3
> len "hello"
5
> len '[a b c]
3
> len 42
1
#+end_src

* DONE ! (range/iota)
#+name: range
#+begin_src imp
> ! 5
0 1 2 3 4
> ! 0

> ! 3
0 1 2
#+end_src

* DONE words (list all defined words)
#+name: words
#+begin_src imp
> words
`nil `+ `- `* `% `^ `min `max `tk `rev `len `! `rd `wr `e? `rm `load `xmls `look `eval `part `type? `show `echo `words
#+end_src

* DONE part (get part of speech)
#+name: part
#+begin_src imp
> part 42
"N"
> part 'echo
"V"
> part '+
"O"
#+end_src

* DONE fold (/) suffix: sum and product
#+name: fold-sum-product
#+begin_src imp
> +/ 1 2 3 4
10
> */ 1 2 3 4
24
> +/ 5
5
#+end_src

* DONE fold (/) suffix: min and max
#+name: fold-min-max
#+begin_src imp
> min/ 5 2 8 1 9
1
> max/ 5 2 8 1 9
9
#+end_src

* DONE scan (\) suffix: running sum
#+name: scan-sum
#+begin_src imp
> +\ 1 2 3 4
1 3 6 10
> *\ 2 3 4
2 6 24
#+end_src

* DONE user-defined functions: basic
#+name: user-fn-basic
#+begin_src imp
> f: {x + 1}
{x + 1}
> f 5
6
> f 10 20 30
11 21 31
#+end_src

* DONE user-defined functions: dyadic
#+name: user-fn-dyadic
#+begin_src imp
> add: {x + y}
{x + y}
> add[3; 5]
8
#+end_src

* DONE user-defined functions: composition
#+name: user-fn-composition
#+begin_src imp
> double: {x * 2}
{x * 2}
> inc: {x + 1}
{x + 1}
> double inc 5
12
#+end_src

* DONE user-defined functions: partial application
#+name: user-fn-partial
#+begin_src imp
> add: {x + y}
{x + y}
> add3: add[3]
{x + y}[3]
> add3[5]
8
#+end_src

* DONE get-word: return function without evaluation
#+name: get-word-function
#+begin_src imp
> f: {x * 2}
{x * 2}
> :f
{x * 2}
> g: :f
{x * 2}
> g 5
10
#+end_src

* DONE get-word: with partial application
#+name: get-word-partial
#+begin_src imp
> add: {x + y}
{x + y}
> add3: add[3]
{x + y}[3]
> :add3
{x + y}[3]
#+end_src

* [0/7] upcoming tests

** TODO ambivalent operators
ex: - x is negate,  x - y is subtraction
x + y is addition,  + x is transpose or complex conjugate

** TODO grammar rules / definitions / macros

** TODO binary expressions
: eq =  ne ~: gt >  lt <  ge >: le <:
: xr ~: an *. or +. nt -.
: lid / rid ? (li/ri?)

** TODO proofs
- unification for rewrite rules
- hehner has two levels (one for expr, one for proofs)
- really just same op with two precedence levels
- quoting might fill the gap?

** TODO tokenizer -> xml test?
