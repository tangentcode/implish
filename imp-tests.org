#+title: implish tests
#+server: https://tangentcode.com/
#+name: implish

* DONE get/set: basic set and get
#+name: get-set-basic
#+begin_src
> set[`x; 42]
42
> get[`x]
42
#+end_src

Basic variable binding using set and retrieval using get.

* DONE get/set: get undefined returns fault
#+name: get-undefined
#+begin_src
> get[`undefined_var]
?undefined_var
#+end_src

When getting an undefined variable, get returns a fault symbol (prefixed with ?).

* DONE get/set: parallel assignment with vector
#+name: get-set-vector
#+begin_src
> set[`a `b `c; 1 2 3]
1 2 3
> get[`a `b `c]
<<1, 2, 3>>
#+end_src

Parallel assignment distributes vector values to multiple variables.

* DONE get/set: scalar broadcast
#+name: get-set-broadcast
#+begin_src
> set[`p `q `r; 99]
99
> get[`p `q `r]
<<99, 99, 99>>
#+end_src

When setting multiple variables to a scalar, all get the same value.

* DONE get/set: mixed defined and undefined
#+name: get-set-mixed
#+begin_src
> set[`alpha; 10]
10
> get[`alpha `beta `gamma]
<<10 ?beta ?gamma>>
#+end_src

Getting a mix of defined and undefined variables returns values and faults.

* DONE repl behavior: print everything but nil
#+name: nil
#+begin_src
> [nil]
[nil]
> nil
> 1 `x
`x
#+end_src

* DONE echo "hello"
#+name: hello.applicative
#+begin_src
> echo "hello"
hello
#+end_src
* DONE echo[2 + 2]
#+name: add
#+begin_src
> echo[2 + 2]
4
#+end_src

outputing "2 2" would be reasonable here if you don't look ahead for operators. So this test forces you to define operators, and look ahead multiple tokens.

- next -> echo (verb)
- have verb, so look ahead for adverb/conjunction/
- peek -> 2 (noun)
- okay. we will apply verb to noun
- fetch full noun phrase, by calling "next"
- next -> 2 (noun)
- have noun, so look ahead for .method or infix op


* DONE arithmetic (left to right eval)
#+name: arithmetic
#+begin_src
> echo[1 + 2 * 3 + 5]
14
#+end_src

* DONE comma sequencing operator
#+name: comma-sequencing
#+begin_src
> 2 + 3 * 5 + 7
32
> 2, + 3 * 5, + 7
24
> ! 10, * 2, + 1
1 3 5 7 9 11 13 15 17 19
> ! 10 * 2 + 1
1 3 5 7 9 11 13 15 17 19
> 1 + 2 * ! 10
0 3 6 9 12 15 18 21 24 27
> 1, + 2 * ! 10
1 3 5 7 9 11 13 15 17 19
#+end_src

* DONE ignore comments
#+name: echo-comment
#+begin_src
> echo .: this is a comment :. "hi"
hi
#+end_src

* DONE echo show "quoted"
#+name: echo-show
#+begin_src
> echo show "quoted"
"quoted"
#+end_src


* DONE echo["hello"]
#+name: hello.projection
#+begin_src
> echo["hello"]
hello
#+end_src

* DONE echo[2 + 2]
#+name: projection.with-op
#+begin_src
> echo[2 + 2]
4
#+end_src

* DONE +[2;3]
#+name: projection.op
#+begin_src
> +[2;3]
5
#+end_src

* DONE echo[+[2;3]]
#+name: projection.nested
#+begin_src
> echo[+[2;3]]
5
#+end_src



* DONE echo xmls '[1 2; "three"; four]
#+name: xmls
#+begin_src imp
> echo xmls [1 2; "three"; 'four]
<imp:lst open="[" close="]">
  <imp:ints v="1 2"/>
  <imp:str v="three"/>
  <imp:sym k="lit" v="four"/>
</imp:lst>
#+end_src

* DONE word type round-tripping: basic types
#+name: word-types-basic
#+begin_src imp
> echo xmls '['foo :bar baz:]
<imp:lst open="[" close="]">
  <imp:sym k="lit" v="foo"/>
  <imp:sym k="get" v="bar"/>
  <imp:sym k="set" v="baz"/>
</imp:lst>
#+end_src

* DONE word type round-tripping: refinement, path, and file
#+name: word-types-refn-path-file
#+begin_src imp
> echo xmls [/refn foo/bar %file/path]
<imp:lst open="[" close="]">
  <imp:sym k="refn" v="refn"/>
  <imp:sym k="path" v="foo/bar"/>
  <imp:sym k="file" v="file/path"/>
</imp:lst>
#+end_src

* TODO word type round-tripping: issue
NOTE: Can't test #abc in tanco because # starts a comment
#+name: word-types-ish
#+begin_src imp
# > xmls [#abc]
# [#abc]
#+end_src

* DONE word type round-tripping: URL
#+name: word-types-url
#+begin_src imp
> echo xmls [http://example.com]
<imp:lst open="[" close="]">
  <imp:sym k="url" v="http://example.com"/>
</imp:lst>
#+end_src

* DONE new symbol types: backtick and type
#+name: word-types-new1
#+begin_src imp
> echo xmls [`foo bar!]
<imp:lst open="[" close="]">
  <imp:sym k="bqt" v="foo"/>
  <imp:sym k="typ" v="bar"/>
</imp:lst>
#+end_src

* DONE new symbol types: annotation and messages
#+name: word-types-new2
#+begin_src imp
> echo xmls '[@note .msg .kw:]
<imp:lst open="[" close="]">
  <imp:sym k="ann" v="note"/>
  <imp:sym k="msg" v="msg"/>
  <imp:sym k="kw" v="kw"/>
</imp:lst>
#+end_src

* DONE new symbol types: message2 and keyword2
#+name: word-types-new3
#+begin_src imp
> echo xmls '[!msg2 !kw2:]
<imp:lst open="[" close="]">
  <imp:sym k="msg2" v="msg2"/>
  <imp:sym k="kw2" v="kw2"/>
</imp:lst>
#+end_src

* DONE new symbol type: error
#+name: word-types-err
#+begin_src imp
> echo xmls [?error]
<imp:lst open="[" close="]">
  <imp:sym k="err" v="error"/>
</imp:lst>
#+end_src

* DONE backtick tokenization: no spaces needed
#+name: backtick-tokenization
#+begin_src imp
> echo xmls '[`foo`bar`baz]
<imp:lst open="[" close="]">
  <imp:sym k="bqt" v="foo"/>
  <imp:sym k="bqt" v="bar"/>
  <imp:sym k="bqt" v="baz"/>
</imp:lst>
#+end_src

* DONE quoted list with backtick (quasiquote)
#+name: quoted-list-backtick
#+begin_src imp
> `[1 2 3]
[1 2 3]
#+end_src

* DONE quoted list with quote (strips one layer)
#+name: quoted-list-quote
#+begin_src imp
> '[a b c]
[a b c]
#+end_src

* DONE quoted list with nested quotes
#+name: quoted-list-nested
#+begin_src imp
> '[a 'b '[c]]
[a 'b '[c]]
#+end_src

* DONE assignment: basic
#+name: assignment-basic
#+begin_src imp
> x: 42
42
> x
42
#+end_src

* DONE assignment: with expression
#+name: assignment-expr
#+begin_src imp
> y: 2 + 3
5
> y
5
#+end_src

* DONE assignment: use assigned value
#+name: assignment-use
#+begin_src imp
> a: 10
10
> b: a + 5
15
> b
15
#+end_src

* DONE assignment: chained
#+name: assignment-chained
#+begin_src imp
> x: y: 42
42
> x
42
> y
42
#+end_src

* DONE assignment: in operator context
#+name: assignment-in-operator
#+begin_src imp
> 1 + a: 2 3 4
3 4 5
> a
2 3 4
> 5 * b: 3
15
> b
3
#+end_src

* DONE load: parse string
#+name: load-string
#+begin_src imp
> load "2 + 3"
2 + 3
#+end_src

* DONE file operations: e?, wr, rd, rm
#+name: file-ops
#+begin_src imp
> f: %hello.txt
%hello.txt
> e? f
0
> wr f "test content"
> e? f
1
> rd f
"test content"
> rm f
#+end_src

* DONE quasiquotation: basic unquote
#+name: quasiquote-basic
#+begin_src imp
> x: 42
42
> `[1 2 ,x]
[1 2, 42]
#+end_src

* DONE quasiquotation: unquote with expression
#+name: quasiquote-expr
#+begin_src imp
> a: 10
10
> b: 20
20
> `[sum is ,a plus ,b]
[sum is 10 plus 20]
#+end_src

* DONE quasiquotation: nested lists
#+name: quasiquote-nested
#+begin_src imp
> y: 99
99
> `[outer [inner ,y]]
[outer [inner 99]]
#+end_src

* DONE quasiquotation: unquote quoted symbol
#+name: quasiquote-unquote-lit
#+begin_src imp
> x: 'two
'two
> `[one ,x three]
[one two three]
#+end_src

* DONE strands: integer vector
#+name: strand-ints
#+begin_src imp
> 1 2 3
1 2 3
> echo 1 2 3 4 5
1 2 3 4 5
#+end_src

* DONE strands: single integer is not a strand
#+name: strand-single
#+begin_src imp
> 42
42
#+end_src

* DONE strands: backtick symbol vector
#+name: strand-syms
#+begin_src imp
> `a `b `c
`a `b `c
> echo `foo `bar `baz
`foo `bar `baz
#+end_src

* DONE strands: scalar plus vector
#+name: strand-scalar-vector
#+begin_src imp
> 1 + 0 1 2
1 2 3
#+end_src

* DONE strands: separated by operators
#+name: strand-ops
#+begin_src imp
> 1 2 + 3 4
4 6
#+end_src

* DONE strands: in projection
#+name: strand-projection
#+begin_src imp
> echo[1 2 3]
1 2 3
#+end_src

* DONE strands: purely syntactic (not semantic)
#+name: strand-syntactic
#+begin_src imp
> 1 2 3
1 2 3
> (0) 1
1
> (1 2) 3
3
> a: 2
2
> b: 3
3
> a b
3
> + a b
5
#+end_src

Strands are formed only from adjacent literal tokens (INT, NUM, backtick symbols), not from evaluated expressions or variables. So `+ a b` passes two separate arguments (variables aren't literals), while `+ 2 3` would form a strand `2 3` as one argument (resulting in partial application).

* DONE strands: as function arguments with comma separator
#+name: strand-func-args-comma
#+begin_src imp
> + 1 2 3, 4 5 6
5 7 9
#+end_src

When collecting function arguments, strands form within each comma-separated argument. The comma acts as an argument separator.

* DONE strands: passed to functions
#+name: strand-func-args
#+begin_src imp
> show 1 2 3
"1 2 3"
#+end_src

When a function collects arguments, adjacent literals form a strand that is passed as a single argument. (Note: using `show` instead of `echo` since `echo` writes to stdout which isn't captured by the test harness)

* DONE type? introspection
#+name: type-int
#+begin_src imp
> echo show type? 3
int!
#+end_src

#+name: type-str
#+begin_src imp
> echo show type? "hello"
str!
#+end_src

#+name: type-sym
#+begin_src imp
> echo show type? `foo
sym!
#+end_src

#+name: type-list
#+begin_src imp
> echo show type? [1 2 3]
lst!
#+end_src

#+name: type-vector-ints
#+begin_src imp
> echo show type? 1 2 3
ints!
#+end_src

#+name: type-nil
#+begin_src imp
> echo show type? nil
nil!
#+end_src

* DONE arithmetic operators
#+name: arithmetic-ops
#+begin_src imp
> 10 + 5
15
> 10 - 5
5
> 10 * 5
50
> 10 % 3
3
> 2 ^ 8
256
#+end_src

* DONE min and max operators
#+name: min-max
#+begin_src imp
> min[3; 7]
3
> max[3; 7]
7
> 1 2 3 min 2 4 1
1 2 1
#+end_src

* DONE tk (take) operator: scalars and vectors
#+name: take-nums
#+begin_src imp
> 5 tk 10
10 10 10 10 10
> 3 tk 1 2
1 2 1
> 4 tk 7 8 9
7 8 9 7
#+end_src

* DONE tk (take) operator: strings and lists
#+name: take-str-lst
#+begin_src imp
> 7 tk "abc"
"abcabca"
> 5 tk '[x y]
[x y x y x]
#+end_src

* DONE rev (reverse)
#+name: rev
#+begin_src imp
> rev 1 2 3 4
4 3 2 1
> rev '[a b c]
[c b a]
> rev `x `y `z
`z `y `x
#+end_src

* DONE len (length)
#+name: len
#+begin_src imp
> len 1 2 3
3
> len "hello"
5
> len '[a b c]
3
> len 42
1
#+end_src

* DONE ! (range/iota)
#+name: range
#+begin_src imp
> ! 5
0 1 2 3 4
> ! 0

> ! 3
0 1 2
#+end_src

* DONE part (get part of speech)
#+name: part
#+begin_src imp
> part 42
"N"
> part 'echo
"V"
> part '+
"V"
#+end_src

* DONE fold (/) suffix: sum and product
#+name: fold-sum-product
#+begin_src imp
> +/ 1 2 3 4
10
> */ 1 2 3 4
24
> +/ 5
5
#+end_src

* DONE fold (/) suffix: min and max
#+name: fold-min-max
#+begin_src imp
> min/ 5 2 8 1 9
1
> max/ 5 2 8 1 9
9
#+end_src

* DONE scan (\) suffix: running sum
#+name: scan-sum
#+begin_src imp
> +\ 1 2 3 4
1 3 6 10
> *\ 2 3 4
2 6 24
#+end_src

* DONE user-defined functions: basic
#+name: user-fn-basic
#+begin_src imp
> f: {x + 1}
{x + 1}
> f 5
6
> f 10 20 30
11 21 31
#+end_src

* DONE user-defined functions: dyadic
#+name: user-fn-dyadic
#+begin_src imp
> add: {x + y}
{x + y}
> add[3; 5]
8
#+end_src

* DONE user-defined functions: composition
#+name: user-fn-composition
#+begin_src imp
> double: {x * 2}
{x * 2}
> inc: {x + 1}
{x + 1}
> double inc 5
12
#+end_src

* DONE user-defined functions: partial application
#+name: user-fn-partial
#+begin_src imp
> add: {x + y}
{x + y}
> add3: add[3]
{x + y}[3]
> add3[5]
8
#+end_src

* DONE get-word: return function without evaluation
#+name: get-word-function
#+begin_src imp
> f: {x * 2}
{x * 2}
> :f
{x * 2}
> g: :f
{x * 2}
> g 5
10
#+end_src

* DONE get-word: with partial application
#+name: get-word-partial
#+begin_src imp
> add: {x + y}
{x + y}
> add3: add[3]
{x + y}[3]
> :add3
{x + y}[3]
#+end_src

* DONE imparse: equivalence of load and quoted blocks
#+name: imparse-equivalence
#+begin_src imp
> imparse load "2 + 3"
+[2 ; 3]
> imparse '[2 + 3]
+[2 ; 3]
#+end_src

Both `load "code"` (creates TOP node) and `'[code]` (regular list) get transformed into TOP nodes with M-expressions.

* DONE imparse: AST for postfix transformation
#+name: imparse-ast-postfix
#+begin_src imp
> imparse '[2 !]
![2]
> imparse '[5 !]
![5]
> imparse '[10 !]
![10]
#+end_src

The parser transforms postfix unary (a F → F[a]) into M-expression form, returning a TOP node.

* DONE imparse: AST for infix transformation
#+name: imparse-ast-infix
#+begin_src imp
> imparse '[2 + 3]
+[2 ; 3]
> imparse '[10 - 3]
-[10 ; 3]
> imparse '[4 * 5]
*[4 ; 5]
#+end_src

The parser transforms infix operators (a op b → op[a; b]) into M-expression form, returning a TOP node.

* DONE imparse: AST for infix chains (left-to-right)
#+name: imparse-ast-chains
#+begin_src imp
> imparse '[2 + 3 * 5]
*[+[2 ; 3] ; 5]
> imparse '[10 - 2 + 5]
+[-[10 ; 2] ; 5]
> imparse '[2 * 3 + 4 * 5]
*[+[*[2 ; 3] ; 4] ; 5]
#+end_src

The parser transforms infix chains left-to-right, creating nested M-expressions in a TOP node.

* DONE imparse: AST handles prefix cases
#+name: imparse-ast-skip-prefix
#+begin_src imp
> imparse '[! 10]
![10]
> imparse '[! 10 * 2]
*[![10] ; 2]
> imparse '[! 10 * 2 + 1]
+[*[![10] ; 2] ; 1]
#+end_src

The parser now handles prefix verbs! Two-pass transformation: first prefix (! 10 → ![10]), then infix/postfix.

* DONE imparse: AST handles comma threading
#+name: imparse-ast-skip-comma
#+begin_src imp
> imparse '[2, + 3]
+[2 ; 3]
> imparse '[2, + 3 * 5]
+[2 ; *[3 ; 5]]
#+end_src

The parser now handles comma threading! When a comma is followed by a verb, it threads the previous value as the first argument.

* DONE imparse: AST skips assignment cases
#+name: imparse-ast-skip-assignment
#+begin_src imp
> x: 99
99
> imparse '[1 + x: 10]
[1 + x: 10]
> imparse '[2 * y: 5]
[2 * y: 5]
#+end_src

When special symbols (SET, GET, LIT, etc.) are present, the parser skips transformation and returns the original list structure.

* [0/7] upcoming tests

** TODO ambivalent operators
ex: - x is negate,  x - y is subtraction
x + y is addition,  + x is transpose or complex conjugate

** TODO grammar rules / definitions / macros

** TODO binary expressions
: eq =  ne ~: gt >  lt <  ge >: le <:
: xr ~: an *. or +. nt -.
: lid / rid ? (li/ri?)

** TODO proofs
- unification for rewrite rules
- hehner has two levels (one for expr, one for proofs)
- really just same op with two precedence levels
- quoting might fill the gap?

** TODO tokenizer -> xml test?

* DONE rln: read line from input
#+name: rln
#+begin_src imp
> rln
> hello
"hello"
#+end_src

This test verifies that rln reads a line from the input stream.
The input provider can be customized for different environments (Node.js, browser, testing, etc.)

* DONE rln: store in variable
#+name: rln-assign
#+begin_src imp
> name: rln
> Alice
"Alice"
> echo name
Alice
#+end_src

* DONE rln: multiple reads
#+name: rln-multiple
#+begin_src imp
> a: rln
> first
"first"
> b: rln
> second
"second"
> a
"first"
> b
"second"
#+end_src
