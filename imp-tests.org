#+title: implish tests
#+server: https://tangentcode.com/
#+name: implish

* DONE repl behavior: print everything but nil
#+name: nil
#+begin_src
> [nil]
[nil]
> nil
> 1 `x
`x
#+end_src

* DONE echo "hello"
#+name: hello.applicative
#+begin_src
> echo "hello"
hello
#+end_src
* DONE echo 2 + 2
#+name: add
#+begin_src
> echo 2 + 2
4
#+end_src

outputing "2 2" would be reasonable here if you don't look ahead for operators. So this test forces you to define operators, and look ahead multiple tokens.

- next -> echo (verb)
- have verb, so look ahead for adverb/conjunction/
- peek -> 2 (noun)
- okay. we will apply verb to noun
- fetch full noun phrase, by calling "next"
- next -> 2 (noun)
- have noun, so look ahead for .method or infix op


* DONE arithmetic (left to right eval)
#+name: arithmetic
#+begin_src
> echo 1 + 2 * 3 + 5
14
#+end_src

* DONE ignore comments
#+name: echo-comment
#+begin_src
> echo .: this is a comment :. "hi"
hi
#+end_src

* DONE echo show "quoted"
#+name: echo-show
#+begin_src
> echo show "quoted"
"quoted"
#+end_src


* DONE echo["hello"]
#+name: hello.projection
#+begin_src
> echo["hello"]
hello
#+end_src

* DONE echo[2 + 2]
#+name: projection.with-op
#+begin_src
> echo[2 + 2]
4
#+end_src

* DONE +[2;3]
#+name: projection.op
#+begin_src
> +[2;3]
5
#+end_src

* DONE echo[+[2;3]]
#+name: projection.nested
#+begin_src
> echo[+[2;3]]
5
#+end_src



* DONE echo xmls [1 2; "three"; four]
#+name: xmls
#+begin_src imp
> echo xmls [1 2; "three"; four]
<imp:lst open="[" close="]">
  <imp:int v="1"/>
  <imp:int v="2"/>
  <imp:sep v=";"/>
  <imp:str v="three"/>
  <imp:sep v=";"/>
  <imp:sym v="four"/>
</imp:lst>
#+end_src

* DONE word type round-tripping: basic types
#+name: word-types-basic
#+begin_src imp
> echo xmls ['foo :bar baz:]
<imp:lst open="[" close="]">
  <imp:sym k="lit" v="foo"/>
  <imp:sym k="get" v="bar"/>
  <imp:sym k="set" v="baz"/>
</imp:lst>
#+end_src

* DONE word type round-tripping: refinement, path, and file
#+name: word-types-refn-path-file
#+begin_src imp
> echo xmls [/refn foo/bar %file/path]
<imp:lst open="[" close="]">
  <imp:sym k="refn" v="refn"/>
  <imp:sym k="path" v="foo/bar"/>
  <imp:sym k="file" v="file/path"/>
</imp:lst>
#+end_src

* TODO word type round-tripping: issue
NOTE: Can't test #abc in tanco because # starts a comment
#+name: word-types-ish
#+begin_src imp
# > xmls [#abc]
# [#abc]
#+end_src

* DONE word type round-tripping: URL
#+name: word-types-url
#+begin_src imp
> echo xmls [http://example.com]
<imp:lst open="[" close="]">
  <imp:sym k="url" v="http://example.com"/>
</imp:lst>
#+end_src

* DONE new symbol types: backtick and type
#+name: word-types-new1
#+begin_src imp
> echo xmls [`foo bar!]
<imp:lst open="[" close="]">
  <imp:sym k="bqt" v="foo"/>
  <imp:sym k="typ" v="bar"/>
</imp:lst>
#+end_src

* DONE new symbol types: annotation and messages
#+name: word-types-new2
#+begin_src imp
> echo xmls [@note .msg .kw:]
<imp:lst open="[" close="]">
  <imp:sym k="ann" v="note"/>
  <imp:sym k="msg" v="msg"/>
  <imp:sym k="kw" v="kw"/>
</imp:lst>
#+end_src

* DONE new symbol types: message2 and keyword2
#+name: word-types-new3
#+begin_src imp
> echo xmls [!msg2 !kw2:]
<imp:lst open="[" close="]">
  <imp:sym k="msg2" v="msg2"/>
  <imp:sym k="kw2" v="kw2"/>
</imp:lst>
#+end_src

* DONE new symbol type: error
#+name: word-types-err
#+begin_src imp
> echo xmls [?error]
<imp:lst open="[" close="]">
  <imp:sym k="err" v="error"/>
</imp:lst>
#+end_src

* DONE backtick tokenization: no spaces needed
#+name: backtick-tokenization
#+begin_src imp
> echo xmls [`foo`bar`baz]
<imp:lst open="[" close="]">
  <imp:sym k="bqt" v="foo"/>
  <imp:sym k="bqt" v="bar"/>
  <imp:sym k="bqt" v="baz"/>
</imp:lst>
#+end_src

* DONE quoted list with backtick (quasiquote)
#+name: quoted-list-backtick
#+begin_src imp
> `[1 2 3]
[1 2 3]
#+end_src

* DONE quoted list with quote (strips one layer)
#+name: quoted-list-quote
#+begin_src imp
> '[a b c]
[a b c]
#+end_src

* DONE quoted list with nested quotes
#+name: quoted-list-nested
#+begin_src imp
> '[a 'b '[c]]
[a 'b '[c]]
#+end_src

* DONE assignment: basic
#+name: assignment-basic
#+begin_src imp
> x: 42
42
> x
42
#+end_src

* DONE assignment: with expression
#+name: assignment-expr
#+begin_src imp
> y: 2 + 3
5
> y
5
#+end_src

* DONE assignment: use assigned value
#+name: assignment-use
#+begin_src imp
> a: 10
10
> b: a + 5
15
> b
15
#+end_src

* DONE assignment: chained
#+name: assignment-chained
#+begin_src imp
> x: y: 42
42
> x
42
> y
42
#+end_src

* DONE load: parse string
#+name: load-string
#+begin_src imp
> load "2 + 3"
2 + 3
#+end_src

* DONE rd: read file
#+name: rd-file
#+begin_src imp
> echo rd %hello.txt
test content
#+end_src

* DONE quasiquotation: basic unquote
#+name: quasiquote-basic
#+begin_src imp
> x: 42
42
> `[1 2 ,x]
[1 2 42]
#+end_src

* DONE quasiquotation: unquote with expression
#+name: quasiquote-expr
#+begin_src imp
> a: 10
10
> b: 20
20
> `[sum is ,a plus ,b]
[sum is 10 plus 20]
#+end_src

* DONE quasiquotation: nested lists
#+name: quasiquote-nested
#+begin_src imp
> y: 99
99
> `[outer [inner ,y]]
[outer [inner 99]]
#+end_src

* DONE quasiquotation: unquote quoted symbol
#+name: quasiquote-unquote-lit
#+begin_src imp
> x: 'two
'two
> `[one ,x three]
[one two three]
#+end_src

* DONE strands: integer vector
#+name: strand-ints
#+begin_src imp
> 1 2 3
1 2 3
> echo 1 2 3 4 5
1 2 3 4 5
#+end_src

* DONE strands: single integer is not a strand
#+name: strand-single
#+begin_src imp
> 42
42
#+end_src

* DONE strands: backtick symbol vector
#+name: strand-syms
#+begin_src imp
> `a `b `c
`a `b `c
> echo `foo `bar `baz
`foo `bar `baz
#+end_src

* DONE strands: scalar plus vector
#+name: strand-scalar-vector
#+begin_src imp
> 1 + 0 1 2
1 2 3
#+end_src

* DONE strands: separated by operators
#+name: strand-ops
#+begin_src imp
> 1 2 + 3 4
4 6
#+end_src

* DONE strands: in projection
#+name: strand-projection
#+begin_src imp
> echo[1 2 3]
1 2 3
#+end_src

* [0/7] upcoming tests

** TODO ambivalent operators
ex: - x is negate,  x - y is subtraction
x + y is addition,  + x is transpose or complex conjugate

** TODO grammar rules / definitions / macros

** TODO binary expressions
: eq =  ne ~: gt >  lt <  ge >: le <:
: xr ~: an *. or +. nt -.
: lid / rid ? (li/ri?)

** TODO proofs
- unification for rewrite rules
- hehner has two levels (one for expr, one for proofs)
- really just same op with two precedence levels
- quoting might fill the gap?

** TODO tokenizer -> xml test?
