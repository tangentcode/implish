#+title: K Primitive Reference for Implish
#+tanco-format: 0.2
#+server: https://tangentcode.com/
#+name: k-primitives
#+todo: TODO SKIP | DONE TEST

This file catalogs all K primitives and their proposed English names for implish.
Each primitive shows examples from the K language (oK manual) for reference.


* Arithmetic Operators
** TEST plus : plus (dyadic +)
#+begin_src
> plus[3; 4 5 6]
7 8 9
> plus["ab"; 5]
102 103
#+end_src

Dyadic =+= is addition. Fully atomic.

** TEST flip : flip (monadic +:)
#+begin_src
> flip [1 2; 3 4]
[[1, 3] [2, 4]]
> flip [5; 3 4]
[[5, 3] [5, 4]]
#+end_src

Monadic =+:= is transpose/flip. Takes the transpose of matrices.
Atoms are spread to match the dimension of other columns.

** TEST minus : minus (dyadic -)
#+begin_src
> minus[23 9; 5 10]
18 -1
#+end_src

Dyadic =-= is subtraction. Fully atomic.

** TEST negate : negate (monadic -:)
#+begin_src
> negate 4 -10 8
-4 10 -8
> negate "b"
-98
#+end_src

Monadic =-:= flips the sign of numbers. Right atomic.

** TEST times : times (dyadic *)
#+begin_src
> times[5 0 -3; 2 2 1]
10 0 -3
#+end_src

Dyadic =*= is multiplication. Fully atomic.

** TEST first : first (monadic *:)
#+begin_src
> first 5 19 8
5
#+end_src

Monadic =*:= extracts the first element of a list.

** TEST first-dict : first-dict (monadic *: for dictionaries)
#+begin_src
> first :[`a 23; `b 34]
23
#+end_src

NOTE: K dictionaries use =[a:val; b:val]= syntax. Implish may use different dictionary syntax.
This extracts the first *value* from a dictionary.

** TEST divide : divide (dyadic %)
#+begin_src
> divide[2 20 9; 0.5 10 2]
4 2 4.5
#+end_src

Dyadic =%= is division. Fully atomic.

** TEST sqrt : sqrt (monadic %:)
#+begin_src
> sqrt 25 7 100
5 2.6457513110645907 10
#+end_src

Monadic =%:= is square root. Right atomic.

** TEST mod : mod (dyadic !)
#+begin_src
> mod[3; 34 2 8]
1 2 2
#+end_src

Dyadic =!= with positive left arg is modulo. Right atomic.

** TEST div : div (dyadic ! with negative left)
#+begin_src
> div[-3; 5 6 27]
1 2 9
#+end_src

Dyadic =!= with negative left arg divides y by x and truncates. Right atomic.

** TEST map : map (dyadic ! for making dictionaries)
#+begin_src
> map[`a `b; 3 4]
:[`a 3; `b 4]
> map[4 5; 6 7]
[4 5 ! 6 7]
#+end_src

Dyadic =!= can make a dictionary from x keys and y value(s).
NOTE: May not translate directly to implish dictionary syntax.

** TEST int : int (monadic !:)
#+begin_src
> int 5
0 1 2 3 4
> int -3
-3 -2 -1
#+end_src

Monadic =!:= generates a range from 0 up to but excluding N.
If N is negative, count up and exclude zero.
(NOTE: Already implemented as =!= in implish)

** TEST odometer : odometer (monadic !: for lists)
#+begin_src
> int 2 3
[0 0 0 1 1 1, 0 1 2 0 1 2]
#+end_src

Monadic =!:= on a list generates ranged permutations (odometer/cartesian product).

** TEST keys : keys (monadic !: for dictionaries)
#+begin_src
> keys :[`a 3; `b 4]
`a `b
#+end_src

Monadic =!:= on a dictionary returns list of keys.
NOTE: Depends on implish dictionary implementation.

* Comparison Operators
** TEST less : less (dyadic <)
#+begin_src
> less[2 3 5; 1 0 6]
0 0 1
#+end_src

Dyadic =<= tests less-than. Fully atomic. Returns boolean (0 or 1).

** TEST asc : asc (monadic <:)
#+begin_src
> asc 5 8 2 7
2 0 3 1
#+end_src

Monadic =<:= is "grade up" or ascending sort indices.
Generates a permutation vector which would sort argument into ascending order.

** TEST asc-dict : asc-dict (monadic <: for dictionaries)
#+begin_src
> asc :[`a 2; `b 5; `c 1]
`c `a `b
#+end_src

Monadic =<:= on dictionaries sorts keys by their values.

** TEST more : more (dyadic >)
#+begin_src
> more[2 3 5; 1 0 6]
1 1 0
#+end_src

Dyadic =>= tests greater-than. Fully atomic. Returns boolean (0 or 1).

** TEST desc : desc (monadic >:)
#+begin_src
> desc 5 8 2 7
1 3 0 2
#+end_src

Monadic =>:= is "grade down" or descending sort indices.
Generates a permutation vector which would sort argument into descending order.

** TEST desc-dict : desc-dict (monadic >: for dictionaries)
#+begin_src
> desc :[`a 2; `b 5; `c 1]
`b `a `c
#+end_src

Monadic =>:= on dictionaries sorts keys by their values (descending).

** TEST equal : equal (dyadic =)
#+begin_src
> equal[3 4 6; 6]
0 0 1
#+end_src

Dyadic === tests equality. Fully atomic. Returns boolean (0 or 1).

** TEST group : group (monadic =:)
#+begin_src
> group `c `a `b `b `a `c `a
:[`c 0 5; `a 1 4 6; `b 2 3]
#+end_src

Monadic =:= generates a dictionary from items to the indices where they were found.
NOTE: Depends on implish dictionary implementation.

** TEST identity-matrix : identity-matrix (monadic =: for numbers)
#+begin_src
> identity-matrix 3
[1 0 0, 0 1 0, 0 0 1]
#+end_src

Monadic =:= on a number generates an NxN identity matrix.

* Logical/Bitwise Operators
** TEST min : min (dyadic &)
#+begin_src
> min[3 5 7; 0 6 9]
0 5 7
#+end_src

Dyadic =&= is minimum. Fully atomic. For booleans, effectively logical AND.

** TEST where : where (monadic &:)
#+begin_src
> where 2 3 1
0 0 1 1 1 2
> where 1 0 0 1 0 1
0 3 5
#+end_src

Monadic =&:= makes N copies of sequential indices.
For boolean lists, gathers indices of nonzero elements.

** TEST where-dict : where-dict (monadic &: for dictionaries)
#+begin_src
> where map[`a `b `c; 1 0 2]
`a `c `c
#+end_src

Monadic =&:= indexes dictionary keys by where of values.

** TEST max : max (dyadic |)
#+begin_src
> max[3 5 7; 0 6 9]
3 6 9
#+end_src

Dyadic =|= is maximum. Fully atomic. For booleans, effectively logical OR.

** TEST reverse : reverse (monadic |:)
#+begin_src
> reverse "ABDEF"
"FEDBA"
#+end_src

Monadic =|:= reverses a list.

** TEST reverse-dict : reverse-dict (monadic |: for dictionaries)
#+begin_src
> reverse :[`a 3; `b 4]
:[`b 4; `a 3]
#+end_src

Monadic =|:= reverses both keys and values in a dictionary.

** TEST match : match (dyadic ~)
#+begin_src
> match[(`a; 2 3 4); (`a; 2 3)]
0
> match[(`a; 2 3 4); (`a; 2 3 4)]
1
#+end_src

Dyadic =~= tests if x and y are recursively identical.
Returns 1 if they match exactly, 0 otherwise.

** TEST not : not (monadic ~:)
#+begin_src
> not [0 1; 3 7 -1]
[1 0, 0 0 0]
#+end_src

Monadic =~:= is logical not. Nonzero numbers become 0, zero becomes 1. Right atomic.

** TEST not-dict : not-dict (monadic ~: for dictionaries)
#+begin_src
> not :[`a [2, 0]; `b 1]
:[`a [0, 1]; `b 0]
#+end_src

Monadic =~:= applies to the values of dictionaries.

* List Construction
** TEST concat : concat (dyadic ,)
#+begin_src
> concat[1; 2 3]
1 2 3
> concat[2; 3]
2 3
> concat[1; nil]
1
#+end_src

Dyadic =,= joins together lists or atoms to produce a list.

** TEST concat-dict : concat-dict (dyadic , for dictionaries)
#+begin_src
> concat[:[`a 1; `b 3]; :[`b 5; `c 7]]
:[`a 1; `b 5; `c 7]
#+end_src

Concatenating dictionaries favors values of y (right argument).

** TEST enlist : enlist (monadic ,:)
#+begin_src
> enlist 1 2 3
[1 2 3]
#+end_src

Monadic =,:= places item in a 1-length list (enlistment).

** TEST count : count (monadic #:)
#+begin_src
> count 4 7 10
3
> count "c"
1
#+end_src

Monadic =#:= counts elements. Atoms have count 1.

** TEST count-dict : count-dict (monadic #: for dictionaries)
#+begin_src
> count :[`a 3; `b 17]
2
#+end_src

Monadic =#:= counts key-value pairs in dictionaries.

** TEST take : take (dyadic #)
#+begin_src
> take[2; "ABC"]
"AB"
> take[6; "ABC"]
"ABCABC"
> take[-2; "ABC"]
"BC"
#+end_src

Dyadic =#= truncates or repeats y to produce a list of length x.
Negative x takes from the end of y.

** TODO take-dict : take-dict (dyadic # with list and dict)
#+begin_src
> take["fb"; map["fab"; 3 5 9]]
map["fb"; 3 9]
#+end_src

Dyadic =#= selects elements from dictionary keyed in x.
NOTE: Not yet implemented. The take function currently only handles integer counts.
Need to extend take to handle string/list of keys as left argument when right is dictionary.

** TEST reshape : reshape (dyadic # with list shapes)
#+begin_src
> reshape[3 2; 1 2 3]
[1 2, 3 1, 2 3]
> reshape[3 2 2; 1 2 3]
[[1 2, 3 1] [2 3, 1 2] [3 1, 2 3]]
#+end_src

Dyadic =#= with list left argument creates arbitrary dimensioned result.
Produces strands (INTs/NUMs/SYMs) at the innermost level for vector inputs.

** TEST reshape-maximal : reshape-maximal (dyadic # with 0N in shape)
#+begin_src
> reshape[0N 3; int 6]
[0 1 2, 3 4 5]
> reshape[2 0N; int 8]
[0 1 2 3, 4 5 6 7]
#+end_src

If leading or trailing element of a length-2 rank vector is =0N=,
reshape treats that dimension as maximal. Produces strands at the innermost level.

** TODO filter : filter (dyadic # with function)
#+begin_src
> filter[{mod[2; x]}; int 8]
1 3 5 7
> filter[{min / x}; (1 0 1 1; 1 1; 0 1 0; 1 2 1)]
(1 1; 1 2 1)
> filter[{match[x; reverse x]}; ("racecar"; "nope"; "bob")]
("racecar"; "bob")
#+end_src

Dyadic =#= with monadic function m filters list by applying m to each element.
Equivalent to =at[l; where each[m; l]]=.
NOTE: Not yet implemented. Requires adverbs (each, /) and higher-order function support.

** TODO filter-dict : filter-dict (dyadic # with function and dict)
#+begin_src
> filter[{mod[2; x]}; map["abcdef"; 2 3 4 5 6 7]]
map["bdf"; 3 5 7]
#+end_src

Dictionaries are filtered by their values and result in dictionaries.
NOTE: Not yet implemented. Depends on filter being implemented first.

** TEST drop : drop (dyadic _)
#+begin_src
> drop[3; "ABCDE"]
"DE"
> drop[-3; "ABCDE"]
"AB"
#+end_src

Dyadic =_= removes x elements from the start of y.
Negative x drops from the end.

** TODO drop-dict : drop-dict (dyadic _ with list and dict)
#+begin_src
> drop[`b `e; map[`a `b `c; 3 5 9]]
map[`a `c; 3 9]
#+end_src

Dyadic =_= filters out keys from a dictionary.
NOTE: Not yet implemented. The drop function currently only handles integer counts.
Need to extend drop to handle list of keys as left argument when right is dictionary.

** TEST cut : cut (dyadic _ with list indices)
#+begin_src
> cut[0 4; "feedface"]
["feed" "face"]
> cut[1 2 4; "feedface"]
["e" "ed" "face"]
#+end_src

Dyadic =_= with list of indices splits y at those indices.
Indices must be ascending.

** TODO filter-out : filter-out (dyadic _ with function)
#+begin_src
> filter-out[{mod[2; x]}; int 8]
0 2 4 6
> filter-out[{min / x}; (1 0 1 1; 1 1; 0 1 0; 1 2 1)]
(1 0 1 1; 0 1 0)
> filter-out[{match[x; reverse x]}; ("racecar"; "nope"; "bob")]
("nope")
#+end_src

Dyadic =_= with monadic function m filters out elements where m returns truthy.
Equivalent to =at[l; where not each[m; l]]=.
NOTE: Not yet implemented. Requires adverbs and higher-order function support.

** TODO filter-out-dict : filter-out-dict (dyadic _ with function and dict)
#+begin_src
> filter-out[{mod[2; x]}; map["abcdef"; 2 3 4 5 6 7]]
map["ace"; 2 4 6]
#+end_src

Dictionaries are filtered-out by their values.
NOTE: Not yet implemented. Depends on filter-out being implemented first.

** TEST floor : floor (monadic _:)
#+begin_src
> floor 2.3 7.6 9 -2.3
2 7 9 -3
#+end_src

Monadic =_:= is floor function. Right atomic.

** TEST lowercase : lowercase (monadic _: for characters)
#+begin_src
> lowercase "ABCdef!"
"abcdef!"
#+end_src

Monadic =_:= converts characters to lowercase. Right atomic.

* List Operations
** TEST null : null (monadic ^:)
#+begin_src
> null? [5; `; 0N]
0 1 1
#+end_src

Monadic =^:= tests if item is null. Right atomic.
Returns 1 for null values (=`= or =0N=), 0 otherwise.

** TEST except : except (dyadic ^)
#+begin_src
> except[1 3 2 5 1 2 3; 1 3 5]
2 2
#+end_src

Dyadic =^= removes all instances of each item in y from x.

** TEST fill : fill (dyadic ^ with atom left)
#+begin_src
> fill["c"; [5; `; 0N]]
[5 "c" "c"]
#+end_src

Dyadic =^= replaces all nulls in y with x.

** TEST distinct : distinct (monadic ?:)
#+begin_src
> distinct [[`a `b]; 3; [`a `b]; 7; 3]
[[`a `b] 3, 7]
#+end_src

Monadic =?:= produces a list of unique elements.

** TODO random-floats : random-floats (monadic ?: for numbers)
#+begin_src
> random-floats 6
0.197 0.8382 0.1811 0.9084 0.6113 0.1958
#+end_src

Monadic =?:= on a number produces x random floats from 0 up to but excluding 1.
(Note: actual values will vary)
NOTE: Not yet implemented. Need to add random-floats function.

** TEST find : find (dyadic ?)
#+begin_src
> find["XYZ"; "XYXZB"]
0 1 0 2 0N
#+end_src

Dyadic =?= determines the index of y in x. Returns =0N= if not found. Right atomic.
For strings, treats them as character arrays.

** TEST find-dict : find-dict (dyadic ? with dict)
#+begin_src
> find[map[`a `b `c `d; 23 14 9 5]; 9 14]
`c `b
#+end_src

Dyadic =?= on dictionaries looks up the key associated with the value y. Right atomic.

** TODO random : random (dyadic ? with numbers)
#+begin_src
> random[5; 10]
0 3 3 7 7
> random[5; 10]
3 5 2 7 9
#+end_src

Dyadic =?= with numbers produces x random integers from 0 up to but excluding y.
(Note: actual values will vary)
NOTE: Not yet implemented. Need to add random number generation.

** TODO random-pick : random-pick (dyadic ? with list)
#+begin_src
> random-pick[8; "ABC"]
"ACBBCBCB"
#+end_src

Dyadic =?= picks x random elements from list y.
(Note: actual values will vary)
NOTE: Not yet implemented. Depends on random being implemented first.

** TODO random-chars : random-chars (dyadic ? with character)
#+begin_src
> random-chars[10; "A"]
"GHIJKLMNOP"
> random-chars[10; "0"]
"0123456789"
#+end_src

Dyadic =?= with character picks random elements from the 26 characters including and up from that char.
(Note: actual values will vary)
NOTE: Not yet implemented. Depends on random being implemented first.

** TODO random-distinct : random-distinct (dyadic ? with negative count)
#+begin_src
> random-distinct[-5; 10]
3 7 1 9 2
> random-distinct[-8; "ABC"]
"CABCABCA"
#+end_src

For =n ? n= or =n ? l=, if x is negative, pick abs(x) distinct items.
(Note: actual values will vary)
NOTE: Not yet implemented. Depends on random being implemented first.

* Type and Conversion
** TEST type : type (monadic @:)
#+begin_src
> type `a
-11
> type "d"
-10
> type nil
0
#+end_src

Monadic =@:= returns a magic number indicating the type of the noun.
General lists are 0, listy things are positive, non-listy things are negative.

** TEST at : at (dyadic @)
#+begin_src
> at[3 7 8; 0 1 1]
3 7 7
> at[negate; 5]
-5
#+end_src

Dyadic =@= indexes a list or applies single argument to a function.
Invalid indices produce =0N=.
NOTE: Function application works for built-in functions but not yet for implish functions (would need evaluator context).

** TEST at-dict : at-dict (dyadic @ with dict)
#+begin_src
> at[map[`a `b; 4 7]; `a]
4
#+end_src

Dyadic =@= indexes a dictionary. Invalid keys produce nil (which doesn't print in REPL; K would produce =0N=).

** TEST string : string (monadic $:)
#+begin_src
> string 120 4
["120" "4"]
> string `beef
"beef"
#+end_src

Monadic =$:= converts atoms into strings. Right atomic.

** TEST pad : pad (dyadic $)
#+begin_src
> pad[5; "beef"]
"beef "
> pad[-7; "beef"]
"   beef"
#+end_src

Dyadic =$= adjusts strings to x characters long.
Under length: right-pad with spaces. Over length: strip from end.
Negative x pads/strips from left.
NOTE: Current implementation only handles single strings, not lists of strings with different padding lengths.

** TEST cast : cast (dyadic $ with symbol)
#+begin_src
> cast[`i; "Hello."]
72 101 108 108 111 46
> cast[`c; 72 101 108 108 111 46]
"Hello."
> cast[`f `i `b; 31]
[31, 31, 1]
#+end_src

Dyadic =$= converts values to different types based on a symbol. Fully atomic.
Conversion symbols: =`c= (char), =`i= (int), =`f= (float), =`b= (bool), =`= (str to sym).

** TEST value : value (monadic .:)
#+begin_src
> value "1 + 2"
3
#+end_src

Monadic =.:= evaluates implish expressions from strings.

** TEST value-dict : value-dict (monadic .: for dict)
#+begin_src
> value map[`a `b; 11 22]
11 22
#+end_src

Monadic =.:= gives the values of a dictionary.

** TODO value-func : value-func (monadic .: for function)
#+begin_src
> value {plus[x; y]}
[in: {match[x; y]; not null find[y; x]}]
#+end_src

Monadic =.:= gives the bound environment of a function as a dictionary (oK-specific).
NOTE: Not yet implemented. This is oK-specific functionality that may not apply to implish.

** TODO dot-apply : dot-apply (dyadic .)
#+begin_src
> dot-apply[[2 3; 4 5]; 1 0]
4
> dot-apply[{concat[x; times[2; y]]}; 3 5]
3 10
#+end_src

Dyadic =.= indexes at depth or applies a list of arguments to a function.
NOTE: Not yet implemented. Need to add dot-apply for deep indexing and function application.

** TODO bind : bind (dyadic . with function and dict)
#+begin_src
> f: bind[{a +:: x}; map[`a; 100]]
{[x] a::. `a plus x}
> at[f; 5]
105
> at[f; 20]
125
> value f
map[`a; 125]
#+end_src

Dyadic =.= treats the dictionary as new global scope for function (oK-specific).
NOTE: Not yet implemented. This is oK-specific functionality for binding closures.

* Adverbs (Suffixes)
** TEST each : each (monadic ')
#+begin_src
> each[{times[2; x]}; 5 7 2]
10 14 4
#+end_src

Monadic ='= applies the monad to each element, producing a new list.
If x is an atom, this is equivalent to =at[m; a]=.

** TEST each2 : each-dyad (dyadic ')
#+begin_src
> each2[{concat[x; times[2; y]]}; 2 7 9; 1 3 4]
[2 2, 7 6, 9 8]
> each2[concat; 5; 1 3 4]
[5 1, 5 3, 5 4]
#+end_src

Dyadic ='= pairs up values from x and y and applies them to the dyad.
If x or y is an atom, spread it to the elements of the other sequence.

** TODO eachprior : eachprior (dyadic ':)
#+begin_src
> eachprior[equal; 3 3 4 4 5]
0 1 0 1 0
> eachprior[minus; 1 3 5 2 9]
1 2 2 -3 7
> eachprior[concat; 2 3 4]
((2); (3 2); (4 3))
#+end_src

Dyadic =':= applies dyad to each element (left) and preceding element (right).
First element paired with 0N, or special initial values for =plus=, =times=, =minus=, =min= (0, 1, 0, first element).
Comma =concat= provided with only 1 parameter for first element.

** TODO eachprior-init : eachprior-init (dyadic ': with initial value)
#+begin_src
> eachprior[concat; 99; 2 3 4]
(2 99; 3 2; 4 3)
#+end_src

Dyadic =':= with atom left specifies explicit initial value for eachprior.

** TODO stencil : stencil (monadic ': with count)
#+begin_src
> stencil[{over[join; string x]}; 3; 11 22 33 44]
("112233"; "223344")
#+end_src

Monadic =':= with number applies monad to overlapping windows of specified size.
Convenience for "each window".

** TODO eachright : eachright (dyadic /:)
#+begin_src
> eachright[concat; 2 3; 4 5 6]
(2 3 4; 2 3 5; 2 3 6)
#+end_src

Dyadic =/:= applies dyad to entire left argument and each right argument.

** TODO eachleft : eachleft (dyadic \:)
#+begin_src
> eachleft[concat; 2 3; 4 5 6]
(2 4 5 6; 3 4 5 6)
#+end_src

Dyadic =\:= applies dyad to each left argument and entire right argument.

** TODO over : over (dyadic /)
#+begin_src
> over[plus; 4 5 2]
11
#+end_src

Dyadic =/= is fold/reduce. Applies dyad left-to-right, carrying result forward.
Special initial values for empty lists: =plus= → 0, =times= → 1, =max= → -∞, =min= → +∞.

** TODO over-init : over-init (dyadic / with initial value)
#+begin_src
> over[plus; 4; 5 2]
11
#+end_src

Dyadic =/= with initial value x applies fold starting from x.

** TODO fixedpoint : fixedpoint (monadic /)
#+begin_src
> fixedpoint[{divide[floor x; 2]}; 32]
0
#+end_src

Monadic =/= repeatedly applies monad until value stops changing or repeats initial value.

** TODO for : for (monadic / with count)
#+begin_src
> for[enlist; 5; 7]
(((((7)))))
#+end_src

Monadic =/= with number applies monad x times.

** TODO while : while (monadic / with condition)
#+begin_src
> while[{less[x; 100]}; {times[x; 2]}; 1]
128
#+end_src

Monadic =/= with two monads applies right monad while left monad returns true.

** TODO scan : scan (dyadic \)
#+begin_src
> scan[plus; 4 5 6]
4 9 15
#+end_src

Dyadic =\= is scan. Like over/fold, but accumulates intermediate results.

** TODO scan-init : scan-init (dyadic \ with initial value)
#+begin_src
> scan[times; 2; 3 2 9]
6 12 108
#+end_src

Dyadic =\= with initial value x starts scan from x.
Note: initial value not included in results.

** TODO scan-fixedpoint : scan-fixedpoint (monadic \)
#+begin_src
> scan-fixedpoint[{divide[floor x; 2]}; 32]
32 16 8 4 2 1 0
> scan-fixedpoint[{mod[3; plus[1; x]]}; 2]
2 0 1
#+end_src

Monadic =\= repeatedly applies monad until stops changing, accumulating results.

** TODO scan-for : scan-for (monadic \ with count)
#+begin_src
> scan-for[enlist; 5; 7]
(7; (7); ((7)); (((7))); ((((7)))); (((((7))))))
#+end_src

Monadic =\= with number applies monad x times, accumulating results.

** TODO scan-while : scan-while (monadic \ with condition)
#+begin_src
> scan-while[{less[x; 100]}; {times[x; 2]}; 1]
1 2 4 8 16 32 64 128
#+end_src

Monadic =\= with two monads applies while condition true, accumulating results.

* verbs that reuse adverb symbols in k
** TEST bin : bin (dyadic ' for lists)
#+begin_src
> bin[0 2 4 6 8 10; 5]
2
> bin[0 2 4 6 8 10; -10 0 4 5 6 20]
-1 0 2 2 3 5
#+end_src

Dyadic ='= with list left argument performs binary search for y in x.
x must already be sorted. Right atomic.

** TEST join : join (dyadic / with atom/list)
#+begin_src
> join["|"; ["a"; "bc"; "def"]]
"a|bc|def"
#+end_src

Dyadic =/= with character/string joins strings with separator.
NOTE: Use square brackets for lists in implish.

** TEST encode : encode (dyadic / with lists)
#+begin_src
> encode[2 2 2; 1 0 1]
5
> encode[10 10 10; 3 4 5]
345
#+end_src

Dyadic =/= combines digits y in base x into single value.

** TEST split : split (dyadic \ with atom/list)
#+begin_src
> split[","; "cat,dog,banana"]
["cat" "dog" "banana"]
#+end_src

Dyadic =\= breaks string y at instances of character x.

** TEST decode : decode (dyadic \ with lists)
#+begin_src
> decode[2 2 2; 5]
1 0 1
> decode[10 10 10; 345]
3 4 5
#+end_src

Dyadic =\= splits number y into base x representation.

** TEST window : window (dyadic ': with number)
#+begin_src
> window[3; int 5]
[0 1 2, 1 2 3, 2 3 4]
> window[2; int 5]
[0 1, 1 2, 2 3, 3 4]
#+end_src

Dyadic =':= creates sliding window of length x from y.
If x < 0: equivalent to =window[3; concat[0; concat[y; 0]]]=.
If x = 0: equivalent to =reshape[plus[1; count y]; nil]=.

* Special Forms
** TEST splice : splice (ternadic ?)
#+begin_src
> splice[1 2 3; 1 1; 4]
1 4 2 3
> splice["test"; 1 3; "u"]
"tut"
> splice["hello world"; 0 5; "goodbye"]
"goodbye world"
#+end_src

Ternadic =?= replaces elements in interval [start end] with value.
NOTE: May require special parsing in implish.

** TEST splice-transform : splice-transform (ternadic ? with function)
#+begin_src
> splice[2 7 9; 1 2; times[2]]
2 14 9
> splice["a look back"; 2 6; reverse]
"a kool back"
#+end_src

If third arg is monadic function, applies to interval instead of replacing.
NOTE: K uses ={times[2; x]}= lambda syntax, implish uses partial application =times[2]=.
** TEST try : error-trap
#+begin_src
> try[plus; [1; 2]]
[0, 3]
> try[plus; [`a; 2]]
[1 "expected number or vector, got: SYM"]
#+end_src

Calls function with args, catches errors.
Returns =[0; result]= on success, =[1; error-message]= on failure.
NOTE: K uses ={plus[1; x]}= lambda syntax with single arg =(1)=. Implish uses =plus= with arg list =[1; 2]=.

** TEST cond : cond (special $)
#+begin_src
> cond[1; "A"; 0; "B"; "C"]
"A"
> cond[0; "A"; 0; "B"; "C"]
"C"
#+end_src

The symbol =$= with 3+ arguments is cond (like Lisp cond).
Considers arguments in pairs: if first is truthy, return second. Else continue.
If no conditions match, return final value.
NOTE: Already described in ok-manual but under special section, not verbs.
Truthy: anything except 0, 0x00, or nil.

* Named Builtins
** TEST sin : sin (monadic)
#+begin_src
> sin 0 0.5 3.141
0 0.479425538604203 0.0005926535550994539
#+end_src

Monadic =sin= calculates sine. Atomic.

** TEST cos : cos (monadic)
#+begin_src
> cos 0 0.5 3.141
1 0.8775825618903728 -0.9999998243808664
#+end_src

Monadic =cos= calculates cosine. Atomic.

** TEST exp : exp (monadic)
#+begin_src
> exp 1 5 12
2.718281828459045 148.4131591025766 162754.79141900392
#+end_src

Monadic =exp= calculates exponential (e^x). Atomic.

** TEST log : log (monadic)
#+begin_src
> log 2.7183 5 10
1.0000066849139877 1.6094379124341003 2.302585092994046
#+end_src

Monadic =log= calculates natural logarithm. Atomic.

** TEST prm : prm (monadic)
#+begin_src
> prm "AB"
["AB" "BA"]
> prm 3
[0 1 2, 0 2 1, 1 0 2, 1 2 0, 2 0 1, 2 1 0]
#+end_src

Monadic =prm= generates all permutations of items in list.
If x is a number, treats as =int x=.

** TEST in : in (dyadic)
#+begin_src
> in[1 3 7; 1 2 3 4 5]
1 1 0
#+end_src

Dyadic =in= tests membership. Is x a member of y? Left-atomic.

* TODO Symbol Aliases

Once the English-named primitives are implemented, add these symbol aliases:

** Arithmetic
- =+= alias for =plus=
- =+:= alias for =flip=
- =-= alias for =minus=
- =-:= alias for =negate=
- =*= alias for =times=
- =*:= alias for =first=
- =%=alias for =divide=
- =%:= alias for =sqrt=
- =!= alias for =mod/div/map= (ambivalent based on left arg sign)
- =!:= alias for =int/odometer/keys= (ambivalent based on arg type)

** Comparison
- =<= alias for =less=
- =<:= alias for =asc=
- =>= alias for =more=
- =>:= alias for =desc=
- === alias for =equal=
- ==:= alias for =group/identity-matrix= (ambivalent based on arg type)

** Logical
- =&= alias for =min=
- =&:= alias for =where=
- =|= alias for =max=
- =|:= alias for =reverse=
- =~= alias for =match=
- =~:= alias for =not=

** List Construction
- =,= alias for =concat=
- =,:= alias for =enlist=
- =#= alias for =take/reshape/filter= (ambivalent based on arg types)
- =#:= alias for =count=
- =_= alias for =drop/cut/filter-out= (ambivalent based on arg types)
- =_:= alias for =floor/lowercase= (ambivalent based on arg type)

** List Operations
- =^= alias for =except/fill= (ambivalent based on left arg)
- =^:= alias for =null=
- =?= alias for =find/random/random-pick= (ambivalent)
- =?:= alias for =distinct/random-floats= (ambivalent)

** Type/Conversion
- =@= alias for =at=
- =@:= alias for =type=
- =$= alias for =pad/cast= (ambivalent)
- =$:= alias for =string=
- =.= alias for =dot-apply/bind= (ambivalent)
- =.:= alias for =value=

** Adverbs (already use symbols)
- ='= (each, each-dyad, bin)
- =':= (eachprior, stencil, window)
- =/= (over, fixedpoint, for, while, join, encode)
- =\= (scan variants, split, decode)
- =/:= (eachright)
- =\:= (eachleft)
