#+title: K Primitive Reference for Implish
#+tanco-format: 0.2
#+server: https://tangentcode.com/
#+name: k-primitives
#+todo: TODO SKIP | DONE TEST

This file catalogs all K primitives and their proposed English names for implish.
Each primitive shows examples from the K language (oK manual) for reference.


* Arithmetic Operators

** TEST plus : plus (dyadic +)
#+begin_src
> plus[3; 4 5 6]
7 8 9
> plus["ab"; 5]
102 103
#+end_src

Dyadic =+= is addition. Fully atomic.

** TEST flip : flip (monadic +:)
#+begin_src
> flip [1 2; 3 4]
[[1, 3] [2, 4]]
> flip [5; 3 4]
[[5, 3] [5, 4]]
#+end_src

Monadic =+:= is transpose/flip. Takes the transpose of matrices.
Atoms are spread to match the dimension of other columns.

** TEST minus : minus (dyadic -)
#+begin_src
> minus[23 9; 5 10]
18 -1
#+end_src

Dyadic =-= is subtraction. Fully atomic.

** TEST negate : negate (monadic -:)
#+begin_src
> negate 4 -10 8
-4 10 -8
> negate "b"
-98
#+end_src

Monadic =-:= flips the sign of numbers. Right atomic.

** TEST times : times (dyadic *)
#+begin_src
> times[5 0 -3; 2 2 1]
10 0 -3
#+end_src

Dyadic =*= is multiplication. Fully atomic.

** TEST first : first (monadic *:)
#+begin_src
> first 5 19 8
5
#+end_src

Monadic =*:= extracts the first element of a list.

** TEST first-dict : first-dict (monadic *: for dictionaries) :mismatch:
#+begin_src
> first :[`a 23; `b 34]
23
#+end_src

NOTE: K dictionaries use =[a:val; b:val]= syntax. Implish may use different dictionary syntax.
This extracts the first *value* from a dictionary.

** TEST divide : divide (dyadic %)
#+begin_src
> divide[2 20 9; 0.5 10 2]
4 2 4.5
#+end_src

Dyadic =%= is division. Fully atomic.

** TODO sqrt : sqrt (monadic %:) :precision:
#+begin_src
> sqrt 25 7 100
5 2.6458 10
#+end_src

Monadic =%:= is square root. Right atomic.

** TEST mod : mod (dyadic !)
#+begin_src
> mod[3; 34 2 8]
1 2 2
#+end_src

Dyadic =!= with positive left arg is modulo. Right atomic.

** TEST div : div (dyadic ! with negative left)
#+begin_src
> div[-3; 5 6 27]
1 2 9
#+end_src

Dyadic =!= with negative left arg divides y by x and truncates. Right atomic.

** TEST map : map (dyadic ! for making dictionaries)
#+begin_src
> map[`a `b; 3 4]
:[`a 3; `b 4]
> map[4 5; 6 7]
[4 5 ! 6 7]
#+end_src

Dyadic =!= can make a dictionary from x keys and y value(s).
NOTE: May not translate directly to implish dictionary syntax.

** TEST int : int (monadic !:)
#+begin_src
> int 5
0 1 2 3 4
> int -3
-3 -2 -1
#+end_src

Monadic =!:= generates a range from 0 up to but excluding N.
If N is negative, count up and exclude zero.
(NOTE: Already implemented as =!= in implish)

** TEST odometer : odometer (monadic !: for lists)
#+begin_src
> int 2 3
[0 0 0 1 1 1, 0 1 2 0 1 2]
#+end_src

Monadic =!:= on a list generates ranged permutations (odometer/cartesian product).

** TEST keys : keys (monadic !: for dictionaries)
#+begin_src
> keys :[`a 3; `b 4]
`a `b
#+end_src

Monadic =!:= on a dictionary returns list of keys.
NOTE: Depends on implish dictionary implementation.

* Comparison Operators

** TEST less : less (dyadic <)
#+begin_src
> less[2 3 5; 1 0 6]
0 0 1
#+end_src

Dyadic =<= tests less-than. Fully atomic. Returns boolean (0 or 1).

** TEST asc : asc (monadic <:)
#+begin_src
> asc 5 8 2 7
2 0 3 1
#+end_src

Monadic =<:= is "grade up" or ascending sort indices.
Generates a permutation vector which would sort argument into ascending order.

** TEST asc-dict : asc-dict (monadic <: for dictionaries)
#+begin_src
> asc :[`a 2; `b 5; `c 1]
`c `a `b
#+end_src

Monadic =<:= on dictionaries sorts keys by their values.

** TEST more : more (dyadic >)
#+begin_src
> more[2 3 5; 1 0 6]
1 1 0
#+end_src

Dyadic =>= tests greater-than. Fully atomic. Returns boolean (0 or 1).

** TEST desc : desc (monadic >:)
#+begin_src
> desc 5 8 2 7
1 3 0 2
#+end_src

Monadic =>:= is "grade down" or descending sort indices.
Generates a permutation vector which would sort argument into descending order.

** TEST desc-dict : desc-dict (monadic >: for dictionaries) :mismatch:
#+begin_src
> desc :[`a 2; `b 5; `c 1]
`b `a `c
#+end_src

Monadic =>:= on dictionaries sorts keys by their values (descending).

** TEST equal : equal (dyadic =)
#+begin_src
> equal[3 4 6; 6]
0 0 1
#+end_src

Dyadic === tests equality. Fully atomic. Returns boolean (0 or 1).

** TEST group : group (monadic =:)
#+begin_src
> group `c `a `b `b `a `c `a
:[`c 0 5; `a 1 4 6; `b 2 3]
#+end_src

Monadic =:= generates a dictionary from items to the indices where they were found.
NOTE: Depends on implish dictionary implementation.

** TEST identity-matrix : identity-matrix (monadic =: for numbers)
#+begin_src
> identity-matrix 3
[1 0 0, 0 1 0, 0 0 1]
#+end_src

Monadic =:= on a number generates an NxN identity matrix.

* Logical/Bitwise Operators

** TEST min : min (dyadic &)
#+begin_src
> min[3 5 7; 0 6 9]
0 5 7
#+end_src

Dyadic =&= is minimum. Fully atomic. For booleans, effectively logical AND.

** TEST where : where (monadic &:)
#+begin_src
> where 2 3 1
0 0 1 1 1 2
> where 1 0 0 1 0 1
0 3 5
#+end_src

Monadic =&:= makes N copies of sequential indices.
For boolean lists, gathers indices of nonzero elements.

** TEST where-dict : where-dict (monadic &: for dictionaries)
#+begin_src
> where map[`a `b `c; 1 0 2]
`a `c `c
#+end_src

Monadic =&:= indexes dictionary keys by where of values.

** TEST max : max (dyadic |)
#+begin_src
> max[3 5 7; 0 6 9]
3 6 9
#+end_src

Dyadic =|= is maximum. Fully atomic. For booleans, effectively logical OR.

** TEST reverse : reverse (monadic |:)
#+begin_src
> reverse "ABDEF"
"FEDBA"
#+end_src

Monadic =|:= reverses a list.

** TEST reverse-dict : reverse-dict (monadic |: for dictionaries)
#+begin_src
> reverse :[`a 3; `b 4]
:[`b 4; `a 3]
#+end_src

Monadic =|:= reverses both keys and values in a dictionary.

** TEST match : match (dyadic ~)
#+begin_src
> match[(`a; 2 3 4); (`a; 2 3)]
0
> match[(`a; 2 3 4); (`a; 2 3 4)]
1
#+end_src

Dyadic =~= tests if x and y are recursively identical.
Returns 1 if they match exactly, 0 otherwise.

** TEST not : not (monadic ~:)
#+begin_src
> not [0 1; 3 7 -1]
[1 0, 0 0 0]
#+end_src

Monadic =~:= is logical not. Nonzero numbers become 0, zero becomes 1. Right atomic.

** TODO not-dict : not-dict (monadic ~: for dictionaries) :mismatch:
#+begin_src
> not :[`a [2, 0]; `b 1]
:[`a [0, 1]; `b 0]
#+end_src

Monadic =~:= applies to the values of dictionaries.

* List Construction

** TEST concat : concat (dyadic ,)
#+begin_src
> concat[1; 2 3]
[1, 2, 3]
> concat[2; 3]
[2, 3]
> concat[1; nil]
1
#+end_src

Dyadic =,= joins together lists or atoms to produce a list.

** TODO concat-dict : concat-dict (dyadic , for dictionaries) :mismatch:
#+begin_src
> concat[:[`a 1; `b 3]; :[`b 5; `c 7]]
:[`a 1; `b 5; `c 7]
#+end_src

Concatenating dictionaries favors values of y (right argument).

** TEST enlist : enlist (monadic ,:)
#+begin_src
> enlist 1 2 3
[1 2 3]
#+end_src

Monadic =,:= places item in a 1-length list (enlistment).

** TEST count : count (monadic #:)
#+begin_src
> count 4 7 10
3
> count "c"
1
#+end_src

Monadic =#:= counts elements. Atoms have count 1.

** TODO count-dict : count-dict (monadic #: for dictionaries) :mismatch:
#+begin_src
> count :[`a 3; `b 17]
2
#+end_src

Monadic =#:= counts key-value pairs in dictionaries.

** TEST take : take (dyadic #)
#+begin_src
> take[2; "ABC"]
"AB"
> take[6; "ABC"]
"ABCABC"
> take[-2; "ABC"]
"BC"
#+end_src

Dyadic =#= truncates or repeats y to produce a list of length x.
Negative x takes from the end of y.

** TODO take-dict : take-dict (dyadic # with list and dict) :mismatch:parser:
#+begin_src
> take["fb"; "fab"!3 5 9]
"fb"!3 9
#+end_src

Dyadic =#= selects elements from dictionary keyed in x.

** TODO reshape : reshape (dyadic # with list shapes)
#+begin_src
> reshape[3 2; 1 2 3]
(1 2; 3 1; 2 3)
> reshape[3 2 2; 1 2 3]
((1 2; 3 1); (2 3; 1 2); (3 1; 2 3))
#+end_src

Dyadic =#= with list left argument creates arbitrary dimensioned result.

** TODO reshape-maximal : reshape-maximal (dyadic # with 0N in shape)
#+begin_src
> reshape[0N 3; int 6]
(0 1 2; 3 4 5)
> reshape[2 0N; int 8]
(0 1 2 3; 4 5 6 7)
#+end_src

If leading or trailing element of a length-2 rank vector is =0N=,
reshape treats that dimension as maximal.

** TODO filter : filter (dyadic # with function)
#+begin_src
> filter[{mod[2; x]}; int 8]
1 3 5 7
> filter[{min / x}; (1 0 1 1; 1 1; 0 1 0; 1 2 1)]
(1 1; 1 2 1)
> filter[{match[x; reverse x]}; ("racecar"; "nope"; "bob")]
("racecar"; "bob")
#+end_src

Dyadic =#= with monadic function m filters list by applying m to each element.
Equivalent to =at[l; where each[m; l]]=.

** TODO filter-dict : filter-dict (dyadic # with function and dict) :mismatch:
#+begin_src
> filter[{mod[2; x]}; "abcdef"!2 3 4 5 6 7]
"bdf"!3 5 7
#+end_src

Dictionaries are filtered by their values and result in dictionaries.

** TEST drop : drop (dyadic _)
#+begin_src
> drop[3; "ABCDE"]
"DE"
> drop[-3; "ABCDE"]
"AB"
#+end_src

Dyadic =_= removes x elements from the start of y.
Negative x drops from the end.

** TODO drop-dict : drop-dict (dyadic _ with list and dict) :mismatch:
#+begin_src
> drop[`b `e; `a `b `c!3 5 9]
`a `c!3 9
#+end_src

Dyadic =_= filters out keys from a dictionary.

** TODO cut : cut (dyadic _ with list indices)
#+begin_src
> cut[0 4; "feedface"]
("feed"; "face")
> cut[1 2 4; "feedface"]
("e"; "ed"; "face")
#+end_src

Dyadic =_= with list of indices splits y at those indices.
Indices must be ascending.

** TODO filter-out : filter-out (dyadic _ with function)
#+begin_src
> filter-out[{mod[2; x]}; int 8]
0 2 4 6
> filter-out[{min / x}; (1 0 1 1; 1 1; 0 1 0; 1 2 1)]
(1 0 1 1; 0 1 0)
> filter-out[{match[x; reverse x]}; ("racecar"; "nope"; "bob")]
("nope")
#+end_src

Dyadic =_= with monadic function m filters out elements where m returns truthy.
Equivalent to =at[l; where not each[m; l]]=.

** TODO filter-out-dict : filter-out-dict (dyadic _ with function and dict) :mismatch:
#+begin_src
> filter-out[{mod[2; x]}; "abcdef"!2 3 4 5 6 7]
"ace"!2 4 6
#+end_src

Dictionaries are filtered-out by their values.

** TEST floor : floor (monadic _:)
#+begin_src
> floor 2.3 7.6 9 -2.3
2 7 9 -3
#+end_src

Monadic =_:= is floor function. Right atomic.

** TEST lowercase : lowercase (monadic _: for characters)
#+begin_src
> lowercase "ABCdef!"
"abcdef!"
#+end_src

Monadic =_:= converts characters to lowercase. Right atomic.

* List Operations

** TODO null : null (monadic ^:) :syntax:
#+begin_src
> null [5; `; 0N]
0 1 1
#+end_src

Monadic =^:= tests if item is null. Right atomic.
Returns 1 for null values (=`= or =0N=), 0 otherwise.

** TEST except : except (dyadic ^)
#+begin_src
> except[1 3 2 5 1 2 3; 1 3 5]
2 2
#+end_src

Dyadic =^= removes all instances of each item in y from x.

** TODO fill : fill (dyadic ^ with atom left)
#+begin_src
> fill["c"; (5; `; 0N)]
(5; "c"; "c")
#+end_src

Dyadic =^= replaces all nulls in y with x.

** TODO distinct : distinct (monadic ?:)
#+begin_src
> distinct ((`a `b); 3; (`a `b); 7; 3)
((`a `b); 3; 7)
#+end_src

Monadic =?:= produces a list of unique elements.

** TODO random-floats : random-floats (monadic ?: for numbers)
#+begin_src
> random-floats 6
0.197 0.8382 0.1811 0.9084 0.6113 0.1958
#+end_src

Monadic =?:= on a number produces x random floats from 0 up to but excluding 1.
(Note: actual values will vary)

** TODO find : find (dyadic ?) :strings:
#+begin_src
> find["XYZ"; "XYXZB"]
0 1 0 2 0N
#+end_src

Dyadic =?= determines the index of y in x. Returns =0N= if not found. Right atomic.

** TODO find-dict : find-dict (dyadic ? with dict) :mismatch:
#+begin_src
> find[`a `b `c `d!23 14 9 5; 9 14]
`c `b
#+end_src

Dyadic =?= on dictionaries looks up the key associated with the value y. Right atomic.

** TODO random : random (dyadic ? with numbers)
#+begin_src
> random[5; 10]
0 3 3 7 7
> random[5; 10]
3 5 2 7 9
#+end_src

Dyadic =?= with numbers produces x random integers from 0 up to but excluding y.
(Note: actual values will vary)

** TODO random-pick : random-pick (dyadic ? with list)
#+begin_src
> random-pick[8; "ABC"]
"ACBBCBCB"
#+end_src

Dyadic =?= picks x random elements from list y.
(Note: actual values will vary)

** TODO random-chars : random-chars (dyadic ? with character)
#+begin_src
> random-chars[10; "A"]
"GHIJKLMNOP"
> random-chars[10; "0"]
"0123456789"
#+end_src

Dyadic =?= with character picks random elements from the 26 characters including and up from that char.
(Note: actual values will vary)

** TODO random-distinct : random-distinct (dyadic ? with negative count)
#+begin_src
> random-distinct[-5; 10]
3 7 1 9 2
> random-distinct[-8; "ABC"]
"CABCABCA"
#+end_src

For =n ? n= or =n ? l=, if x is negative, pick abs(x) distinct items.
(Note: actual values will vary)

* Type and Conversion

** TEST type : type (monadic @:)
#+begin_src
> type `a
-11
> type "d"
-10
> type nil
0
#+end_src

Monadic =@:= returns a magic number indicating the type of the noun.
General lists are 0, listy things are positive, non-listy things are negative.

** TODO at : at (dyadic @) :needs-list-indexing:
#+begin_src
> at[3 7 8; 0 1 1]
3 7 7
> at[{times[x; x]}; 5]
25
#+end_src

Dyadic =@= indexes a list or applies single argument to a function.
Invalid indices produce =0N=.

** TODO at-dict : at-dict (dyadic @ with dict) :mismatch:
#+begin_src
> at[:[`a 4; `b 7]; `a]
4
> at[:[`a 4; `b 7]; `q]
0N
#+end_src

Dyadic =@= indexes a dictionary. Invalid keys produce =0N=.

** TEST string : string (monadic $:)
#+begin_src
> string 120 4
["120" "4"]
> string `beef
"beef"
#+end_src

Monadic =$:= converts atoms into strings. Right atomic.

** TODO pad : pad (dyadic $)
#+begin_src
> pad[5; "beef"]
"beef "
> pad[-7; "beef"]
"   beef"
> pad[2 3 4; ("a"; "b"; "c")]
("a "; "b  "; "c   ")
#+end_src

Dyadic =$= adjusts strings to x characters long.
Under length: right-pad with spaces. Over length: strip from end.
Negative x pads/strips from left. Mostly fully atomic, strings treated specially.

** TODO cast : cast (dyadic $ with symbol)
#+begin_src
> cast[`i; "Hello."]
72 101 108 108 111 46
> cast[`c; 72 101 108 108 111 46]
"Hello."
> cast[`f `i `b; 31]
31 31 1
#+end_src

Dyadic =$= converts values to different types based on a symbol. Fully atomic.
Conversion symbols: =`c= (char), =`i= (int), =`f= (float), =`b= (bool), =`= (str to sym).

** TODO value : value (monadic .:)
#+begin_src
> value "1 + 2"
3
#+end_src

Monadic =.:= evaluates K expressions from strings.

** TODO value-dict : value-dict (monadic .: for dict) :mismatch:
#+begin_src
> value :[`a 11; `b 22]
11 22
#+end_src

Monadic =.:= gives the values of a dictionary.

** TODO value-func : value-func (monadic .: for function) :mismatch:
#+begin_src
> value {plus[x; y]}
[in: {match[x; y]; not null find[y; x]}]
#+end_src

Monadic =.:= gives the bound environment of a function as a dictionary (oK-specific).

** TODO dot-apply : dot-apply (dyadic .)
#+begin_src
> dot-apply[(2 3; 4 5); 1 0]
4
> dot-apply[{concat[x; times[2; y]]}; 3 5]
3 10
#+end_src

Dyadic =.= indexes at depth or applies a list of arguments to a function.

** TODO bind : bind (dyadic . with function and dict) :mismatch:
#+begin_src
> f: bind[{a +:: x}; :[`a 100]]
{[x] a::. `a plus x}
> at[f; 5]
105
> at[f; 20]
125
> value f
:[`a 125]
#+end_src

Dyadic =.= treats the dictionary as new global scope for function (oK-specific).

* Adverbs (Suffixes)

** TODO each : each (monadic ')
#+begin_src
> each[{times[2; x]}; 5 7 2]
10 14 4
#+end_src

Monadic ='= applies the monad to each element, producing a new list.
If x is an atom, this is equivalent to =at[m; a]=.

** TODO each-dyad : each-dyad (dyadic ')
#+begin_src
> each[{concat[x; times[2; y]]}; 2 7 9; 1 3 4]
(2 2; 7 6; 9 8)
> each[concat; 5; 1 3 4]
(5 1; 5 3; 5 4)
#+end_src

Dyadic ='= pairs up values from x and y and applies them to the dyad.
If x or y is an atom, spread it to the elements of the other sequence.

** TODO bin : bin (dyadic ' for lists)
#+begin_src
> bin[0 2 4 6 8 10; 5]
2
> bin[0 2 4 6 8 10; -10 0 4 5 6 20]
-1 0 2 2 3 5
#+end_src

Dyadic ='= with list left argument performs binary search for y in x.
x must already be sorted. Right atomic.

** TODO eachprior : eachprior (dyadic ':)
#+begin_src
> eachprior[equal; 3 3 4 4 5]
0 1 0 1 0
> eachprior[minus; 1 3 5 2 9]
1 2 2 -3 7
> eachprior[concat; 2 3 4]
((2); (3 2); (4 3))
#+end_src

Dyadic =':= applies dyad to each element (left) and preceding element (right).
First element paired with 0N, or special initial values for =plus=, =times=, =minus=, =min= (0, 1, 0, first element).
Comma =concat= provided with only 1 parameter for first element.

** TODO eachprior-init : eachprior-init (dyadic ': with initial value)
#+begin_src
> eachprior[concat; 99; 2 3 4]
(2 99; 3 2; 4 3)
#+end_src

Dyadic =':= with atom left specifies explicit initial value for eachprior.

** TODO stencil : stencil (monadic ': with count)
#+begin_src
> stencil[{over[join; string x]}; 3; 11 22 33 44]
("112233"; "223344")
#+end_src

Monadic =':= with number applies monad to overlapping windows of specified size.
Convenience for "each window".

** TODO eachright : eachright (dyadic /:)
#+begin_src
> eachright[concat; 2 3; 4 5 6]
(2 3 4; 2 3 5; 2 3 6)
#+end_src

Dyadic =/:= applies dyad to entire left argument and each right argument.

** TODO eachleft : eachleft (dyadic \:)
#+begin_src
> eachleft[concat; 2 3; 4 5 6]
(2 4 5 6; 3 4 5 6)
#+end_src

Dyadic =\:= applies dyad to each left argument and entire right argument.

** TODO over : over (dyadic /)
#+begin_src
> over[plus; 4 5 2]
11
#+end_src

Dyadic =/= is fold/reduce. Applies dyad left-to-right, carrying result forward.
Special initial values for empty lists: =plus= → 0, =times= → 1, =max= → -∞, =min= → +∞.

** TODO over-init : over-init (dyadic / with initial value)
#+begin_src
> over[plus; 4; 5 2]
11
#+end_src

Dyadic =/= with initial value x applies fold starting from x.

** TODO fixedpoint : fixedpoint (monadic /)
#+begin_src
> fixedpoint[{divide[floor x; 2]}; 32]
0
#+end_src

Monadic =/= repeatedly applies monad until value stops changing or repeats initial value.

** TODO for : for (monadic / with count)
#+begin_src
> for[enlist; 5; 7]
(((((7)))))
#+end_src

Monadic =/= with number applies monad x times.

** TODO while : while (monadic / with condition)
#+begin_src
> while[{less[x; 100]}; {times[x; 2]}; 1]
128
#+end_src

Monadic =/= with two monads applies right monad while left monad returns true.

** TODO scan : scan (dyadic \)
#+begin_src
> scan[plus; 4 5 6]
4 9 15
#+end_src

Dyadic =\= is scan. Like over/fold, but accumulates intermediate results.

** TODO scan-init : scan-init (dyadic \ with initial value)
#+begin_src
> scan[times; 2; 3 2 9]
6 12 108
#+end_src

Dyadic =\= with initial value x starts scan from x.
Note: initial value not included in results.

** TODO scan-fixedpoint : scan-fixedpoint (monadic \)
#+begin_src
> scan-fixedpoint[{divide[floor x; 2]}; 32]
32 16 8 4 2 1 0
> scan-fixedpoint[{mod[3; plus[1; x]]}; 2]
2 0 1
#+end_src

Monadic =\= repeatedly applies monad until stops changing, accumulating results.

** TODO scan-for : scan-for (monadic \ with count)
#+begin_src
> scan-for[enlist; 5; 7]
(7; (7); ((7)); (((7))); ((((7)))); (((((7))))))
#+end_src

Monadic =\= with number applies monad x times, accumulating results.

** TODO scan-while : scan-while (monadic \ with condition)
#+begin_src
> scan-while[{less[x; 100]}; {times[x; 2]}; 1]
1 2 4 8 16 32 64 128
#+end_src

Monadic =\= with two monads applies while condition true, accumulating results.

** TODO join : join (dyadic / with atom/list)
#+begin_src
> join["|"; ("a"; "bc"; "def")]
"a|bc|def"
#+end_src

Dyadic =/= with character/string joins strings with separator.

** TODO encode : encode (dyadic / with lists)
#+begin_src
> encode[2 2 2; 1 0 1]
5
> encode[10 10 10; 3 4 5]
345
#+end_src

Dyadic =/= combines digits y in base x into single value.

** TODO split : split (dyadic \ with atom/list)
#+begin_src
> split[","; "cat,dog,banana"]
("cat"; "dog"; "banana")
#+end_src

Dyadic =\= breaks string y at instances of character x.

** TODO decode : decode (dyadic \ with lists)
#+begin_src
> decode[2 2 2; 5]
1 0 1
> decode[10 10 10; 345]
3 4 5
#+end_src

Dyadic =\= splits number y into base x representation.

** TODO window : window (dyadic ': with number)
#+begin_src
> window[3; int 5]
(0 1 2; 1 2 3; 2 3 4)
> window[2; int 5]
(0 1; 1 2; 2 3; 3 4)
#+end_src

Dyadic =':= creates sliding window of length x from y.
If x < 0: equivalent to =window[3; concat[0; concat[y; 0]]]=.
If x = 0: equivalent to =reshape[plus[1; count y]; nil]=.

* Special Forms

** TODO splice : splice (ternadic ?) :mismatch:
#+begin_src
> splice[1 2 3; 1 1; 4]
1 4 2 3
> splice["test"; 1 3; "u"]
"tut"
> splice["hello world"; 0 5; "goodbye"]
"goodbye world"
#+end_src

Ternadic =?= replaces elements in interval [start end] with value.
NOTE: May require special parsing in implish.

** TODO splice-transform : splice-transform (ternadic ? with function) :mismatch:
#+begin_src
> splice[2 7 9; 1 2; {times[2; x]}]
2 14 9
> splice["a look back"; 2 6; reverse]
"a kool back"
#+end_src

If third arg is monadic function, applies to interval instead of replacing.

** TODO error-trap : error-trap (ternadic .) :mismatch:
#+begin_src
> error-trap[{plus[1; x]}; (1); :]
(0 2)
> error-trap[{plus[1; x]}; (`a); :]
(1; "number expected, found symbol.")
#+end_src

Ternadic =.= calls function with args, catches errors.
Returns =(0; result)= on success, =(1; error-message)= on failure.
NOTE: Colon =:= used as placeholder. May need different syntax in implish.

** TODO cond : cond (special $) :mismatch:
#+begin_src
> cond[1; "A"; 0; "B"; "C"]
"A"
> cond[0; "A"; 0; "B"; "C"]
"C"
#+end_src

The symbol =$= with 3+ arguments is cond (like Lisp cond).
Considers arguments in pairs: if first is truthy, return second. Else continue.
If no conditions match, return final value.
NOTE: Already described in ok-manual but under special section, not verbs.
Truthy: anything except 0, 0x00, or nil.

* Named Builtins

** TEST sin : sin (monadic)
#+begin_src
> sin 0 0.5 3.141
0 0.479425538604203 0.0005926535550994539
#+end_src

Monadic =sin= calculates sine. Atomic.

** TEST cos : cos (monadic)
#+begin_src
> cos 0 0.5 3.141
1 0.8775825618903728 -0.9999998243808664
#+end_src

Monadic =cos= calculates cosine. Atomic.

** TEST exp : exp (monadic)
#+begin_src
> exp 1 5 12
2.718281828459045 148.4131591025766 162754.79141900392
#+end_src

Monadic =exp= calculates exponential (e^x). Atomic.

** TEST log : log (monadic)
#+begin_src
> log 2.7183 5 10
1.0000066849139877 1.6094379124341003 2.302585092994046
#+end_src

Monadic =log= calculates natural logarithm. Atomic.

** TODO prm : prm (monadic)
#+begin_src
> prm "AB"
("AB"; "BA")
> prm 3
(0 1 2; 0 2 1; 1 0 2; 1 2 0; 2 0 1; 2 1 0)
#+end_src

Monadic =prm= generates all permutations of items in list.
If x is a number, treats as =int x=.

** TEST in : in (dyadic)
#+begin_src
> in[1 3 7; 1 2 3 4 5]
1 1 0
#+end_src

Dyadic =in= tests membership. Is x a member of y? Left-atomic.

* TODO Symbol Aliases

Once the English-named primitives are implemented, add these symbol aliases:

** Arithmetic
- =+= alias for =plus=
- =+:= alias for =flip=
- =-= alias for =minus=
- =-:= alias for =negate=
- =*= alias for =times=
- =*:= alias for =first=
- =%=alias for =divide=
- =%:= alias for =sqrt=
- =!= alias for =mod/div/map= (ambivalent based on left arg sign)
- =!:= alias for =int/odometer/keys= (ambivalent based on arg type)

** Comparison
- =<= alias for =less=
- =<:= alias for =asc=
- =>= alias for =more=
- =>:= alias for =desc=
- === alias for =equal=
- ==:= alias for =group/identity-matrix= (ambivalent based on arg type)

** Logical
- =&= alias for =min=
- =&:= alias for =where=
- =|= alias for =max=
- =|:= alias for =reverse=
- =~= alias for =match=
- =~:= alias for =not=

** List Construction
- =,= alias for =concat=
- =,:= alias for =enlist=
- =#= alias for =take/reshape/filter= (ambivalent based on arg types)
- =#:= alias for =count=
- =_= alias for =drop/cut/filter-out= (ambivalent based on arg types)
- =_:= alias for =floor/lowercase= (ambivalent based on arg type)

** List Operations
- =^= alias for =except/fill= (ambivalent based on left arg)
- =^:= alias for =null=
- =?= alias for =find/random/random-pick= (ambivalent)
- =?:= alias for =distinct/random-floats= (ambivalent)

** Type/Conversion
- =@= alias for =at=
- =@:= alias for =type=
- =$= alias for =pad/cast= (ambivalent)
- =$:= alias for =string=
- =.= alias for =dot-apply/bind= (ambivalent)
- =.:= alias for =value=

** Adverbs (already use symbols)
- ='= (each, each-dyad, bin)
- =':= (eachprior, stencil, window)
- =/= (over, fixedpoint, for, while, join, encode)
- =\= (scan variants, split, decode)
- =/:= (eachright)
- =\:= (eachleft)
