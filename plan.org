#+TITLE: Implish Evaluation Pipeline Refactoring Plan
#+DATE: 2025-11-12

* Overview

** Current Problem
The evaluator combines parsing and evaluation in a single pass using a "parts of speech" approach. This makes it difficult to reason about precedence, function application, and comma sequencing.

** Goal
Refactor the evaluation pipeline into three distinct phases:
1. ~load[]~ - Lexer/tokenizer (already exists)
2. ~imparse[]~ - Parser/normalizer (exists but minimal - needs expansion)
3. ~eval[]~ - Interpreter (needs simplification)

** Key Insight
After parsing, everything should be in M-expression form: ~head[arg1; arg2; ...]~

This makes evaluation trivial: look at the head, evaluate it with the arguments.

* Current Issues

** Bugs Discovered (2025-11-12)

*** Function Application: ~a F~ should be ~F[a]~
#+begin_example
2 !        → <fn[_]>[]     (WRONG: should be ![2] → 0 1)
! 2        → 0 1           (correct)
#+end_example

By the rule ~a F b c d~ → ~F[a; b; c; ...]~, these should be equivalent.

*** Multi-Argument Valence Errors
#+begin_example
2 ! 10     → 0 1 2 3 4 5 6 7 8 9   (WRONG: should be ![2; 10] → valence error)
#+end_example

The ~2~ is being ignored instead of causing an arity mismatch.

*** Comma Threading with Monads
#+begin_example
2, !       → 0 1           (correct: threads 2 to !)
2, ! 10    → 10            (WRONG: unclear what this should be)
#+end_example

*** Multiple Comma Sequences
#+begin_example
5, !, * 3  → Error: evalList: invalid word class: M
#+end_example

** Correct Behaviors (Keep These)
#+begin_example
2, + 3 * 5   → 17          (threading: 2 + (3 * 5))
2 + 3 * 5    → 25          (Q'Nial left-to-right: (2 + 3) * 5)
! 10 * 2     → 0 2 4 ... 18 (monadic eager collection works)
+ 1, 2 3     → 3 4         (comma strand separation works)
#+end_example

* M-Expression Format

** Representation

Internal structure (conceptual):
#+begin_src xml
<imp:list h="*" o="[" c="]">
  <imp:int v="2"/>
  <imp:int v="3"/>
</imp:list>
#+end_src

Display form:
#+begin_example
*[2; 3]
#+end_example

The ~o="["~ and ~c="]"~ are defaults and can be omitted.

** Properties

- Every compound expression becomes a list with a ~head~ (h) field
- The head is what gets evaluated/applied
- The remaining elements are arguments
- This is exactly M-expressions from McCarthy's original Lisp paper
- We use vectors/arrays instead of cons cells

* Transformation Rules (for imparse[])

** Function Application: ~a F b c~ → ~F[a; b; c]~

#+begin_example
Source:  2 !
Load:    [INT(2), SYM(!)]
Parse:   [SYM(!) [INT(2)]]        ; list with head=!
Display: ![2]
Eval:    [INT(0), INT(1)]
#+end_example

#+begin_example
Source:  2 ! 10
Load:    [INT(2), SYM(!), INT(10)]
Parse:   [SYM(!) [INT(2), INT(10)]]
Display: ![2; 10]
Eval:    ERROR: valence error (! has arity 1, got 2 args)
#+end_example

** Infix Operators: ~a op b~ → ~op[a; b]~

#+begin_example
Source:  2 + 3
Load:    [INT(2), SYM(+), INT(3)]
Parse:  [SYM(+) [INT(2), INT(3)]]
Display: +[2; 3]
Eval:    INT(5)
#+end_example

** Precedence/Association: Q'Nial Style (Left-to-Right)

#+begin_example
Source:  2 + 3 * 5
Load:    [INT(2), SYM(+), INT(3), SYM(*), INT(5)]
Parse:  [SYM(*) [[SYM(+) [INT(2), INT(3)]], INT(5)]]
Display: *[+[2; 3]; 5]
Eval:    INT(25)     ; (2 + 3) * 5
#+end_example

This is Q'Nial's "pervasive" style: all infix operators have equal precedence, evaluated left-to-right.

** Comma Threading: ~noun, dyad expr~ → ~dyad[noun; expr]~

#+begin_example
Source:  2, + 3 * 5
Load:    [INT(2), SEP(,), SYM(+), INT(3), SYM(*), INT(5)]
Parse:  [SYM(+) [INT(2), [SYM(*) [INT(3), INT(5)]]]]
Display: +[2; *[3; 5]]
Eval:    INT(17)     ; 2 + (3 * 5)
#+end_example

The comma makes the dyadic operator collect its right-hand side as a complete expression.

** Comma with Monads: ~noun, monad~ → ~monad[noun]~

#+begin_example
Source:  2, !
Load:    [INT(2), SEP(,), SYM(!)]
Parse:  [SYM(!) [INT(2)]]
Display: ![2]
Eval:    [INT(0), INT(1)]
#+end_example

** Strands: ~a b c~ → ~[a; b; c]~ (if no function applies)

#+begin_example
Source:  1 2 3
Load:    [INT(1), INT(2), INT(3)]
Parse:  [LST [INT(1), INT(2), INT(3)]]
Display: 1 2 3
Eval:    [INT(1), INT(2), INT(3)]
#+end_example

Currently handled by ~imparse[]~, should continue to work.

** Projection Syntax: ~F[a; b]~ (already in M-expression form)

#+begin_example
Source:  +[1; 2]
Load:    [SYM(+), LST[INT(1), SEP(;), INT(2)]]
Parse:  [SYM(+) [INT(1), INT(2)]]
Display: +[1; 2]
Eval:    INT(3)
#+end_example

* Test Cases

All of these should pass after refactoring:

** Basic Function Application
| Expression | Result/Error        | Notes                              |
|------------+---------------------+------------------------------------|
| ~! 2~      | ~0 1~               | Prefix application                 |
| ~2 !~      | ~0 1~               | Postfix (converts to prefix)       |
| ~2 ! 10~   | valence error       | ~![2; 10]~ - too many args         |
| ~! 10~     | ~0 1 2 3 4 5 6 7 8 9~ | Normal monadic application         |

** Infix Operators
| Expression   | Result | Notes                           |
|--------------+--------+---------------------------------|
| ~2 + 3~      | ~5~    | Simple infix                    |
| ~2 + 3 * 5~  | ~25~   | Left-to-right: ~(2 + 3) * 5~    |
| ~2 * 3 + 5~  | ~11~   | Left-to-right: ~(2 * 3) + 5~    |

** Comma Threading
| Expression     | Result | Notes                              |
|----------------+--------+------------------------------------|
| ~2, !~         | ~0 1~  | Thread 2 to !                      |
| ~2, + 3~       | ~5~    | Thread 2 to + as first arg         |
| ~2, + 3 * 5~   | ~17~   | Thread: ~2 + (3 * 5)~              |
| ~5, + 10, * 2~ | ~30~   | Multiple threads: ~(5 + 10) * 2~   |

** Comma with Monads (TBD - needs design decision)
| Expression  | Result/Error | Notes                         |
|-------------+--------------+-------------------------------|
| ~2, ! 10~   | TBD          | What should this do?          |
| ~5, !, * 3~ | TBD          | Multiple commas with monads   |

** Strands and Multi-Argument Functions
| Expression | Result | Notes                           |
|------------+--------+---------------------------------|
| ~1 2 3~    | ~1 2 3~ | Integer strand                  |
| ~+ 1, 2 3~ | ~3 4~  | Comma separates strand args     |

** Projection Syntax
| Expression | Result | Notes                   |
|------------+--------+-------------------------|
| ~+[2; 3]~  | ~5~    | Explicit projection     |
| ~![5]~     | ~0 1 2 3 4~ | Explicit call           |

* Implementation Strategy

** Phase 1: Document and Test Current Behavior
1. Create comprehensive test file with expected results
2. Document all edge cases
3. Run tests against current implementation to establish baseline

** Phase 2: Implement imparse[] Transformations
1. Start with simple cases:
   - Function application: ~a F b~ → ~F[a; b]~
   - Infix operators: ~a op b~ → ~op[a; b]~
2. Add precedence handling:
   - Left-to-right association
   - Proper grouping
3. Implement comma threading:
   - Dyadic case: ~noun, dyad expr~
   - Monadic case: ~noun, monad~
4. Keep existing strand handling

** Phase 3: Simplify eval[]
1. Assume all input is in M-expression form
2. For lists: evaluate head, apply to evaluated args
3. For atoms: return as-is
4. Remove complex parts-of-speech logic

** Phase 4: Integration and Testing
1. Run full test suite
2. Fix any regressions
3. Update documentation
4. Performance testing

* Design Decisions Needed

** Comma with Monads: ~2, ! 10~

Options:
1. *Error*: Comma threading doesn't make sense when monad already has an arg
2. *Thread and ignore*: ~(2, !) 10~ → apply ! to 2, then 10 is separate (current behavior?)
3. *No threading*: Comma acts as separator, just evaluate ~! 10~

Need to decide based on use cases.

** Multiple Commas: ~5, !, * 3~

This currently errors with "invalid word class: M".

Options:
1. *Chain threading*: ~(5, !) , (* 3)~ → but what does this mean?
2. *Error*: Disallow this pattern
3. *Separate evaluation*: Each comma starts a new context

Need to clarify intended semantics.

* Open Questions

1. Should ~2 !~ and ~! 2~ really be equivalent? (Answer: yes, per user feedback)
2. What about ~2 + 3~ vs ~+ 2 3~ vs ~+[2; 3]~ - all equivalent?
3. How do projection brackets ~[..]~ interact with spaces and commas?
4. Should there be a way to force prefix application? (like ~(!)[2]~?)
5. What about adverbs, conjunctions, trains? (Future work?)

* Success Criteria

After implementation, these should all be true:

1. All test cases pass
2. ~2 !~ evaluates to ~0 1~ (same as ~! 2~)
3. ~2 ! 10~ gives valence error
4. Comma threading works consistently
5. Q'Nial left-to-right precedence maintained
6. ~eval[]~ code is significantly simpler
7. No performance regression

* References

- McCarthy, John. "Recursive Functions of Symbolic Expressions and Their Computation by Machine, Part I." CACM 1960.
- Q'Nial Reference Manual (for precedence rules)
- questions.org (current issues)
- CLAUDE.md (project overview)
